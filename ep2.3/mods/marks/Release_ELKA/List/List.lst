##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Jul/2010  17:20:24 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\pasha\elf\_MY_PROJECT_\marks\List.cpp             #
#    Command line    =  D:\pasha\elf\_MY_PROJECT_\marks\List.cpp -D          #
#                       NEWSGOLD -D ELKA -lC D:\pasha\elf\_MY_PROJECT_\marks #
#                       \Release_ELKA\List\ -o D:\pasha\elf\_MY_PROJECT_\mar #
#                       ks\Release_ELKA\Obj\ -s9 --no_unroll --cpu_mode arm  #
#                       --endian little --cpu ARM926EJ-S --stack_align 4     #
#                       --interwork -e --fpu None --eec++ --dlib_config      #
#                       "D:\pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\LIB\dl5tpainl8n.h" -I                #
#                       "D:\pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  D:\pasha\elf\_MY_PROJECT_\marks\Release_ELKA\List\Li #
#                       st.lst                                               #
#    Object file     =  D:\pasha\elf\_MY_PROJECT_\marks\Release_ELKA\Obj\Lis #
#                       t.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

D:\pasha\elf\_MY_PROJECT_\marks\List.cpp
      1          //#include <vcl.h>
      2          //#include "Unit1.h"
      3          #include "../inc/swilib.h"
      4          #include "main.h"
      5          #include "List.h"
      6          /*
      7            (c)kluchnik 04.03.2009
      8            v0.1
      9            Сделал на досуге, для общего развития, да и думаю будет полезно...
     10          
     11            Возможности:
     12              Добавление записей в конец списка
     13              Добавление элементов любую позицию списка
     14              Удаление элементов
     15              Изменение элементов
     16              Перемещение
     17          */
     18          
     19          

   \                                 In segment DATA_C, align 1, align-sorted
     20          const char _d[]="%d";
   \                     _d:
   \   00000000   256400             DC8 "%d"
     21          

   \                                 In segment CODE, align 4, keep-with-next
     22          int CList::add(LIST_STRUCT* item)
     23          {
     24            if(!item) return (-1);
   \                     ??add:
   \   00000000   000051E3           CMP      R1,#+0
   \   00000004   0000E003           MVNEQ    R0,#+0
   \   00000008   1EFF2F01           BXEQ     LR
     25            if(!this->toplist) this->toplist = item;
   \   0000000C   002090E5           LDR      R2,[R0, #+0]
   \   00000010   000052E3           CMP      R2,#+0
   \   00000014   00108005           STREQ    R1,[R0, #+0]
   \   00000018   0700000A           BEQ      ??add_3
     26            else
     27            {
     28              LIST_STRUCT *top = this->toplist;
   \   0000001C   140092E5           LDR      R0,[R2, #+20]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0300000A           BEQ      ??add_4
     29              while(top->next) top = top->next;
   \                     ??add_5:
   \   00000028   142092E5           LDR      R2,[R2, #+20]
   \   0000002C   140092E5           LDR      R0,[R2, #+20]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   FBFFFF1A           BNE      ??add_5
     30              top->next = item;
   \                     ??add_4:
   \   00000038   141082E5           STR      R1,[R2, #+20]
     31            }
     32            return (1);
   \                     ??add_3:
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   1EFF2FE1           BX       LR               ;; return
     33          }
     34          

   \                                 In segment CODE, align 4, keep-with-next
     35          int CList::add(char *name)
     36          {
   \                     ??add_1:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
     37            if(!name) return -1;
   \   0000000C   0000E003           MVNEQ    R0,#+0
   \   00000010   F080BD08           POPEQ    {R4-R7,PC}
     38            LIST_STRUCT *l = new LIST_STRUCT();
   \   00000014   1800A0E3           MOV      R0,#+24
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0060B0E1           MOVS     R6,R0
   \   00000020   0070A0E3           MOV      R7,#+0
   \   00000024   0200000A           BEQ      ??add_6
   \   00000028   1810A0E3           MOV      R1,#+24
   \   0000002C   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000030   000000EA           B        ??add_7
   \                     ??add_6:
   \   00000034   0060A0E3           MOV      R6,#+0
     39            l->next = 0;
   \                     ??add_7:
   \   00000038   147086E5           STR      R7,[R6, #+20]
     40            l->name = name;
   \   0000003C   045086E5           STR      R5,[R6, #+4]
     41            this->add(l);
   \   00000040   0610A0E1           MOV      R1,R6
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       ??add
     42            return 0;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   F080BDE8           POP      {R4-R7,PC}       ;; return
     43          }
     44          
     45          

   \                                 In segment CODE, align 4, keep-with-next
     46          int CList::add(int d)
     47          {
   \                     ??add_2:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     48            LIST_STRUCT *l = new LIST_STRUCT();
   \   0000000C   1800A0E3           MOV      R0,#+24
   \   00000010   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000014   0060B0E1           MOVS     R6,R0
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   0200000A           BEQ      ??add_8
   \   00000020   1810A0E3           MOV      R1,#+24
   \   00000024   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000028   000000EA           B        ??add_9
   \                     ??add_8:
   \   0000002C   0060A0E3           MOV      R6,#+0
     49            l->next = 0;
   \                     ??add_9:
   \   00000030   147086E5           STR      R7,[R6, #+20]
     50            l->name = (char*)malloc(32);
   \   00000034   2000A0E3           MOV      R0,#+32
   \   00000038   140000EF           SWI      +20
     51            sprintf(l->name,_d,d);
   \   0000003C   1C109FE5           LDR      R1,??add_10      ;; _d
   \   00000040   040086E5           STR      R0,[R6, #+4]
   \   00000044   0520A0E1           MOV      R2,R5
   \   00000048   160000EF           SWI      +22
     52            this->add(l);
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       ??add
     53            return 0;
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??add_10:
   \   00000060   ........           DC32     _d
     54          }
     55          

   \                                 In segment CODE, align 4, keep-with-next
     56          int CList::Insert(LIST_STRUCT* new_item,int pos)
     57          {
   \                     ??Insert:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     58            if(!this->toplist) return -1;
   \   00000008   007094E5           LDR      R7,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   0000E003           MVNEQ    R0,#+0
   \   0000001C   F080BD08           POPEQ    {R4-R7,PC}
     59            if(pos > this->Count()) return -2;
   \   00000020   ........           BL       ??Count
   \   00000024   060050E1           CMP      R0,R6
   \   00000028   0100E0B3           MVNLT    R0,#+1
   \   0000002C   F080BDB8           POPLT    {R4-R7,PC}
     60            
     61            LIST_STRUCT* prev_item = NULL;
   \   00000030   0000A0E3           MOV      R0,#+0
     62            LIST_STRUCT* cur_item = this->toplist;
   \   00000034   0710A0E1           MOV      R1,R7
     63          
     64            int i=0;
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   010000EA           B        ??Insert_2
     65            while(/*cur_item!=NULL && */(i++ < pos))
     66            {
     67              prev_item = cur_item;
   \                     ??Insert_3:
   \   00000040   0100A0E1           MOV      R0,R1
     68              cur_item = cur_item->next;
   \   00000044   141091E5           LDR      R1,[R1, #+20]
     69            }
   \                     ??Insert_2:
   \   00000048   0230A0E1           MOV      R3,R2
   \   0000004C   012083E2           ADD      R2,R3,#+1
   \   00000050   060053E1           CMP      R3,R6
   \   00000054   F9FFFFBA           BLT      ??Insert_3
     70          
     71            
     72            if(prev_item == NULL)
   \   00000058   000050E3           CMP      R0,#+0
     73            {
     74              new_item->next = toplist;
   \   0000005C   14708505           STREQ    R7,[R5, #+20]
     75              toplist = new_item;
   \   00000060   00508405           STREQ    R5,[R4, #+0]
     76            }
     77            else
     78            {
     79              prev_item->next = new_item;
   \   00000064   14508015           STRNE    R5,[R0, #+20]
     80              new_item->next = cur_item;
   \   00000068   14108515           STRNE    R1,[R5, #+20]
     81            }
     82            return 0;
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   F080BDE8           POP      {R4-R7,PC}       ;; return
     83          }
     84          

   \                                 In segment CODE, align 4, keep-with-next
     85          int CList::Insert(char* new_item,int pos)
     86          {
   \                     ??Insert_1:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
     87            LIST_STRUCT *insert = new LIST_STRUCT;
   \   00000010   1800A0E3           MOV      R0,#+24
   \   00000014   ........           _BLF     `??operator new`,`??operator new??rA`
     88            insert->next=0;
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   141080E5           STR      R1,[R0, #+20]
     89            insert->name = new_item;
   \   00000020   045080E5           STR      R5,[R0, #+4]
     90           return (this->Insert(insert,pos));
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0010A0E1           MOV      R1,R0
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   7040BDE8           POP      {R4-R6,LR}       ;; Pop
   \   00000034   ........           B        ??Insert         ;; tailcall
     91          }
     92          

   \                                 In segment CODE, align 4, keep-with-next
     93          int CList::Delete(LIST_STRUCT *del_item,int pos = -1)
     94          {
   \                     ??Delete:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0050A0E1           MOV      R5,R0
     95            if(!this->toplist) return -1;
   \   00000008   004095E5           LDR      R4,[R5, #+0]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0000E003           MVNEQ    R0,#+0
   \   0000001C   F083BD08           POPEQ    {R4-R9,PC}
     96            if(pos > this->Count()) return -2;
   \   00000020   ........           BL       ??Count
   \   00000024   070050E1           CMP      R0,R7
   \   00000028   0100E0B3           MVNLT    R0,#+1
   \   0000002C   F083BDB8           POPLT    {R4-R9,PC}
     97            
     98            LIST_STRUCT* prev_item = NULL;
     99            LIST_STRUCT* tmp_item = NULL;
    100            LIST_STRUCT* cur_item = this->toplist;
    101            int i = 0;
   \   00000030   0080A0E3           MOV      R8,#+0
    102          
    103             //если в качестве аргумента для поиска передана структура,то ищем по ней
    104            // и\или если в качестве позиции указано -1
    105          
    106            //удалить первый итем
    107            //strcmp грубовато...надо придумать что то другое
    108            if(((del_item || pos == -1) ? (!strcmp(del_item->name,cur_item->name)) : (pos == 0)))
   \   00000034   0890E0E1           MVN      R9,R8
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   0100001A           BNE      ??Delete_1
   \   00000040   090057E1           CMP      R7,R9
   \   00000044   0F00001A           BNE      ??Delete_2
   \                     ??Delete_1:
   \   00000048   040096E5           LDR      R0,[R6, #+4]
   \   0000004C   041094E5           LDR      R1,[R4, #+4]
   \   00000050   190000EF           SWI      +25
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0C00000A           BEQ      ??Delete_3
    109            {
    110              tmp_item = toplist;
    111              toplist = toplist->next;
    112              delete tmp_item;
    113              //free(tmp_item);
    114              return 0;
    115            }
    116            else
    117            {
    118              prev_item = NULL;
   \                     ??Delete_4:
   \   0000005C   0050A0E3           MOV      R5,#+0
    119              cur_item = cur_item;
    120          
    121              while(cur_item!=NULL)
    122              {
    123                if(((del_item || pos == -1) ? (!strcmp(del_item->name,cur_item->name))
    124                                            : (pos == i++))) break;
   \                     ??Delete_5:
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   0100001A           BNE      ??Delete_6
   \   00000068   090057E1           CMP      R7,R9
   \   0000006C   0C00001A           BNE      ??Delete_7
   \                     ??Delete_6:
   \   00000070   040096E5           LDR      R0,[R6, #+4]
   \   00000074   041094E5           LDR      R1,[R4, #+4]
   \   00000078   190000EF           SWI      +25
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   0B00001A           BNE      ??Delete_8
   \   00000084   0E0000EA           B        ??Delete_9
   \                     ??Delete_2:
   \   00000088   000057E3           CMP      R7,#+0
   \   0000008C   F2FFFF1A           BNE      ??Delete_4
   \                     ??Delete_3:
   \   00000090   000095E5           LDR      R0,[R5, #+0]
   \   00000094   141090E5           LDR      R1,[R0, #+20]
   \   00000098   001085E5           STR      R1,[R5, #+0]
   \   0000009C   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   000000A0   0D0000EA           B        ??Delete_10
   \                     ??Delete_7:
   \   000000A4   0800A0E1           MOV      R0,R8
   \   000000A8   018080E2           ADD      R8,R0,#+1
   \   000000AC   000057E1           CMP      R7,R0
   \   000000B0   0300000A           BEQ      ??Delete_9
    125                prev_item = cur_item;
   \                     ??Delete_8:
   \   000000B4   0450A0E1           MOV      R5,R4
    126                cur_item = cur_item->next;
   \   000000B8   144094E5           LDR      R4,[R4, #+20]
    127              }
   \   000000BC   000054E3           CMP      R4,#+0
   \   000000C0   E6FFFF1A           BNE      ??Delete_5
    128          
    129              if(cur_item!=NULL)
   \                     ??Delete_9:
   \   000000C4   000054E3           CMP      R4,#+0
   \   000000C8   0300000A           BEQ      ??Delete_10
    130              {
    131                tmp_item = cur_item;
    132                prev_item->next = cur_item->next;
   \   000000CC   140094E5           LDR      R0,[R4, #+20]
   \   000000D0   140085E5           STR      R0,[R5, #+20]
    133                delete tmp_item;
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           _BLF     `??operator delete`,`??operator delete??rA`
    134                //free(tmp_item);
    135              }
    136            }
    137            return 0;
   \                     ??Delete_10:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   F083BDE8           POP      {R4-R9,PC}       ;; return
    138          }
    139          
    140          
    141          //              a,b,c,d
    142          // Swap(0,2) -> c,b,a,d

   \                                 In segment CODE, align 4, keep-with-next
    143          int CList::Swap(int source,int desc)
    144          {
   \                     ??Swap:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    145            if(desc > this->Count()) return -1;
   \   00000010   ........           BL       ??Count
   \   00000014   060050E1           CMP      R0,R6
   \   00000018   0000E0B3           MVNLT    R0,#+0
   \   0000001C   F087BDB8           POPLT    {R4-R10,PC}
    146          
    147            LIST_STRUCT *s_item,*d_item;
    148          
    149            s_item = this->Items(source);
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       ??Items
   \   0000002C   0070A0E1           MOV      R7,R0
    150            d_item = this->Items(desc);
   \   00000030   0610A0E1           MOV      R1,R6
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       ??Items
   \   0000003C   00A0A0E1           MOV      R10,R0
    151          
    152            LIST_STRUCT *t = new LIST_STRUCT();
   \   00000040   1800A0E3           MOV      R0,#+24
   \   00000044   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000048   0090B0E1           MOVS     R9,R0
   \   0000004C   0080A0E3           MOV      R8,#+0
   \   00000050   0200000A           BEQ      ??Swap_1
   \   00000054   1810A0E3           MOV      R1,#+24
   \   00000058   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   0000005C   000000EA           B        ??Swap_2
   \                     ??Swap_1:
   \   00000060   0090A0E3           MOV      R9,#+0
    153            t->name = d_item->name;
   \                     ??Swap_2:
   \   00000064   04009AE5           LDR      R0,[R10, #+4]
   \   00000068   040089E5           STR      R0,[R9, #+4]
    154            t->next = 0;
   \   0000006C   148089E5           STR      R8,[R9, #+20]
    155          
    156            LIST_STRUCT *tt = new LIST_STRUCT();
   \   00000070   1800A0E3           MOV      R0,#+24
   \   00000074   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000078   00A0B0E1           MOVS     R10,R0
   \   0000007C   0200000A           BEQ      ??Swap_3
   \   00000080   1810A0E3           MOV      R1,#+24
   \   00000084   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000088   000000EA           B        ??Swap_4
   \                     ??Swap_3:
   \   0000008C   00A0A0E3           MOV      R10,#+0
    157            tt->name = s_item->name;
   \                     ??Swap_4:
   \   00000090   040097E5           LDR      R0,[R7, #+4]
    158            tt->next = 0;
    159          
    160            Change(t,source);
   \   00000094   0520A0E1           MOV      R2,R5
   \   00000098   04008AE5           STR      R0,[R10, #+4]
   \   0000009C   14808AE5           STR      R8,[R10, #+20]
   \   000000A0   0910A0E1           MOV      R1,R9
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       ??Change
    161            Change(tt,desc);
   \   000000AC   0620A0E1           MOV      R2,R6
   \   000000B0   0A10A0E1           MOV      R1,R10
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       ??Change
    162            return 0;
   \   000000BC   0000A0E3           MOV      R0,#+0
   \   000000C0   F087BDE8           POP      {R4-R10,PC}      ;; return
    163          }
    164          
    165          

   \                                 In segment CODE, align 4, keep-with-next
    166          void CList::Change(LIST_STRUCT *change,int item)
    167          {
   \                     ??Change:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
    168             if(!change) return;
   \   0000000C   000054E3           CMP      R4,#+0
    169             if(!this->toplist) return;
   \   00000010   00709515           LDRNE    R7,[R5, #+0]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   00005713           CMPNE    R7,#+0
   \   0000001C   F080BD08           POPEQ    {R4-R7,PC}
    170             if(item > this->Count()) return;
   \   00000020   ........           BL       ??Count
   \   00000024   060050E1           CMP      R0,R6
   \   00000028   F080BDB8           POPLT    {R4-R7,PC}
    171          
    172             LIST_STRUCT *prev = NULL;
   \   0000002C   0000A0E3           MOV      R0,#+0
    173             LIST_STRUCT *cur = toplist;
    174             LIST_STRUCT *tmp = NULL;
    175          
    176             int i = 0;
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   010000EA           B        ??Change_2
    177             while(i++ < item/* && cur!=NULL*/)
    178             {
    179               prev = cur;
   \                     ??Change_3:
   \   00000038   0700A0E1           MOV      R0,R7
    180               cur = cur->next;
   \   0000003C   147097E5           LDR      R7,[R7, #+20]
    181             }
   \                     ??Change_2:
   \   00000040   0120A0E1           MOV      R2,R1
   \   00000044   011082E2           ADD      R1,R2,#+1
   \   00000048   060052E1           CMP      R2,R6
   \   0000004C   F9FFFFBA           BLT      ??Change_3
    182          
    183            if(prev == NULL)//первый элемент в списке 
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0700001A           BNE      ??Change_4
    184            {
    185              Delete(0,0);
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   ........           BL       ??Delete
    186              change->next = toplist;
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   140084E5           STR      R0,[R4, #+20]
    187              toplist = change;
   \   00000070   004085E5           STR      R4,[R5, #+0]
   \   00000074   F080BDE8           POP      {R4-R7,PC}
    188            }
    189            else
    190             if(cur!=NULL)
   \                     ??Change_4:
   \   00000078   000057E3           CMP      R7,#+0
   \   0000007C   F080BD08           POPEQ    {R4-R7,PC}
    191             {
    192               tmp = cur;
    193               change->next = cur->next;
   \   00000080   141097E5           LDR      R1,[R7, #+20]
   \   00000084   141084E5           STR      R1,[R4, #+20]
    194               prev->next = change;
   \   00000088   144080E5           STR      R4,[R0, #+20]
    195               delete tmp;
   \   0000008C   0700A0E1           MOV      R0,R7
   \   00000090   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   00000094   F080BDE8           POP      {R4-R7,PC}       ;; return
    196             }
    197          }
    198          

   \                                 In segment CODE, align 4, keep-with-next
    199          void CList::Change(char *change,int item)
    200          {
   \                     ??Change_1:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    201            if(!change) return;
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   F080BD08           POPEQ    {R4-R7,PC}
    202            LIST_STRUCT *ch = new LIST_STRUCT();
   \   00000018   1800A0E3           MOV      R0,#+24
   \   0000001C   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000020   0070B0E1           MOVS     R7,R0
   \   00000024   0100000A           BEQ      ??Change_5
   \   00000028   1810A0E3           MOV      R1,#+24
   \   0000002C   ........           _BLF     __data_memzero,??__data_memzero??rA
    203            ch->next=0;
   \                     ??Change_5:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   140087E5           STR      R0,[R7, #+20]
    204            ch->name = change;
   \   00000038   045087E5           STR      R5,[R7, #+4]
    205            this->Change(ch,item);
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0710A0E1           MOV      R1,R7
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       ??Change
    206          }
   \   0000004C   F080BDE8           POP      {R4-R7,PC}       ;; return
    207          

   \                                 In segment CODE, align 4, keep-with-next
    208          void CList::FreeList()
    209          {
   \                     ??FreeList:
   \   00000000   10402DE9           PUSH     {R4,LR}
    210            LIST_STRUCT *t = this->toplist;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    211            this->toplist = NULL;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   001080E5           STR      R1,[R0, #+0]
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1080BD08           POPEQ    {R4,PC}
    212          
    213            while(t/* && t->next*/)
    214            {
    215              LIST_STRUCT *t_prev = t;
   \                     ??FreeList_1:
   \   00000018   0400A0E1           MOV      R0,R4
    216              t = t->next;
   \   0000001C   144094E5           LDR      R4,[R4, #+20]
    217              delete t_prev;
   \   00000020   ........           _BLF     `??operator delete`,`??operator delete??rA`
    218              //free(t_prev);
    219            }
   \   00000024   000054E3           CMP      R4,#+0
   \   00000028   FAFFFF1A           BNE      ??FreeList_1
    220          }
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    221          

   \                                 In segment CODE, align 4, keep-with-next
    222          CList::CList()
    223          {
    224            this->toplist = 0;
   \                     ??CList:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   001080E5           STR      R1,[R0, #+0]
    225            this->list = 0;
   \   00000008   041080E5           STR      R1,[R0, #+4]
    226          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    227          

   \                                 In segment CODE, align 4, keep-with-next
    228          CList::~CList()
    229          {
    230            this->FreeList();
   \                     `?~CList`:
   \   00000000   ........           B        ??FreeList       ;; tailcall
    231          }
    232          
    233          

   \                                 In segment CODE, align 4, keep-with-next
    234          LIST_STRUCT* CList::Items(int curitem)
    235          {
    236            LIST_STRUCT* t = this->toplist;
   \                     ??Items:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    237            int i = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   000000EA           B        ??Items_1
    238            while(t)
    239            {
    240              if(i++ == curitem) return t;
    241              t = (LIST_STRUCT*)t->next;
   \                     ??Items_2:
   \   0000000C   140090E5           LDR      R0,[R0, #+20]
   \                     ??Items_1:
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1EFF2F01           BXEQ     LR
   \   00000018   0230A0E1           MOV      R3,R2
   \   0000001C   012083E2           ADD      R2,R3,#+1
   \   00000020   010053E1           CMP      R3,R1
   \   00000024   F8FFFF1A           BNE      ??Items_2
    242            }
    243            return 0;
   \   00000028   1EFF2FE1           BX       LR               ;; return
    244          }
    245          

   \                                 In segment CODE, align 4, keep-with-next
    246          int CList::Count()
    247          {
    248            LIST_STRUCT* t = this->toplist;
   \                     ??Count:
   \   00000000   001090E5           LDR      R1,[R0, #+0]
    249            int i = 0;
   \   00000004   0000A0E3           MOV      R0,#+0
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   1EFF2F01           BXEQ     LR
    250            while(t)
    251            {
    252              t = (LIST_STRUCT*)t->next;
   \                     ??Count_1:
   \   00000010   141091E5           LDR      R1,[R1, #+20]
    253              i++;
   \   00000014   010080E2           ADD      R0,R0,#+1
    254            }
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   FBFFFF1A           BNE      ??Count_1
    255            return i;
   \   00000020   1EFF2FE1           BX       LR               ;; return
    256          }
    257          
    258          
    259          //==============================================================
    260          //                           menu
    261          //==============================================================
    262          
    263          
    264          extern CList *list;
    265          

   \                                 In segment DATA_Z, align 4, align-sorted
    266          MenuList * MenuList::Active = NULL;
   \                     ??Active:
   \   00000000                      DS8 4
    267          
    268          SOFTKEY_DESC list_sk[]=
    269          {
    270            {0x0018,0x0000,NULL},
    271            {0x0001,0x0000,NULL},
    272            {0x003D,0x0000,(int)LGP_DOIT_PIC}
    273          };
    274          
    275          SOFTKEYSTAB list_skt=
    276          {
    277            list_sk,0
    278          };
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          void list_ghook(void * data, int cmd)
    281          {
    282            MenuList::Active->gHook(data, cmd);
    283          }
   \                     ??list_ghook:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    284          

   \                                 In segment CODE, align 4, keep-with-next
    285          void list_itemhndl(void * data, int curitem, void * unk)
    286          {
    287            MenuList::Active->ItemHandler(data, curitem, unk);
   \                     ??list_itemhndl:
   \   00000000   0230A0E1           MOV      R3,R2
   \   00000004   0120A0E1           MOV      R2,R1
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   ........           LDR      R0,??DataTable6  ;; ??Active
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   ........           B        ??ItemHandler    ;; tailcall
    288          }
    289          

   \                                 In segment CODE, align 4, keep-with-next
    290          int list_keyhook(void * data, GUI_MSG *msg)
    291          {
    292            return MenuList::Active->onKey(data, msg);
   \                     ??list_keyhook:
   \   00000000   0120A0E1           MOV      R2,R1
   \   00000004   0010A0E1           MOV      R1,R0
   \   00000008   ........           LDR      R0,??DataTable6  ;; ??Active
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   ........           B        ??onKey          ;; tailcall
    293          }

   \                                 In segment DATA_I, align 4, align-sorted
    294          
    295          HEADER_DESC list_hdr={0,0,0,0, NULL, NULL, LGP_NULL};
   \                     list_hdr:
   \   00000000                      DS8 20
   \   00000014                      REQUIRE `?<Initializer for list_hdr>`
   \                     list_sk:
   \   00000014                      DS8 24
   \   0000002C                      REQUIRE `?<Initializer for list_sk>`

   \                                 In segment DATA_I, align 4, align-sorted
   \                     list_skt:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for list_skt>`
    296          

   \                                 In segment DATA_C, align 4, align-sorted
    297          const int list_softkeys[]={0,1,2};
   \                     list_softkeys:
   \   00000000   000000000100       DC32 0, 1, 2
   \              000002000000
    298          

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Delete">`:
   \   00000000   44656C657465       DC8 "Delete"
   \              00          
   \   00000007   00                 DC8 0
   \   00000008   4578697400         DC8 "Exit"
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   08000000....       DC32 8, ??list_keyhook, ??list_ghook, 0H, list_softkeys, list_skt, 529
   \              ............
   \              00000000....
   \              ............
   \              11020000    
   \   0000002C   ........0000       DC32 ??list_itemhndl, 0H, 0H, 0, 1
   \              000000000000
   \              000000000100
   \              0000        
    299          static const ML_MENU_DESC list_desc=
    300          {
    301            8, list_keyhook, list_ghook, NULL,
    302            list_softkeys,
    303            &list_skt,
    304            0x200 + 0x11,
    305            list_itemhndl,
    306            NULL,   // Items
    307            NULL,   // Procs
    308            NULL,   // n
    309            1       // Добавочных строк  
    310          };
    311          

   \                                 In segment CODE, align 4, keep-with-next
    312          int MenuList::onKey(void * data, GUI_MSG * msg)
    313          {
   \                     ??onKey:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    314            {
    315              int i;
    316              i=GetCurMenuItem(data);
   \   00000008   0400A0E1           MOV      R0,R4
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   8F0100EF           SWI      +399
    317              if(msg->keys == 0x3D)
    318              {
    319              }
    320              
    321              if (msg->keys == 0x18)
   \   00000014   F210D5E1           LDRSH    R1,[R5, #+2]
   \   00000018   180051E3           CMP      R1,#+24
    322              {
    323                return 1;    
   \   0000001C   0100A003           MOVEQ    R0,#+1
   \   00000020   3080BD08           POPEQ    {R4,R5,PC}
    324              }
    325              
    326              if (msg->gbsmsg->msg == KEY_DOWN)
   \   00000024   041095E5           LDR      R1,[R5, #+4]
   \   00000028   9330A0E3           MOV      R3,#+147
   \   0000002C   042091E5           LDR      R2,[R1, #+4]
   \   00000030   403F83E3           ORR      R3,R3,#0x100
   \   00000034   030052E1           CMP      R2,R3
    327              {
    328                switch(msg->gbsmsg->submess)
   \   00000038   08109105           LDREQ    R1,[R1, #+8]
   \   0000003C   23005103           CMPEQ    R1,#+35
   \   00000040   0D00001A           BNE      ??onKey_1
    329                {
    330                  case '#':
    331                    {
    332                      ///list->Delete(NULL,i);
    333                      extern void DelItem(MNU *);
    334                      DelItem(list->Items(i));
   \   00000044   ........           LDR      R5,??DataTable5  ;; list
   \   00000048   0010A0E1           MOV      R1,R0
   \   0000004C   000095E5           LDR      R0,[R5, #+0]
   \   00000050   ........           BL       ??Items
   \   00000054   ........           _BLF     ??DelItem,??DelItem??rA
    335                      Menu_SetItemCountDyn(data,list->Count());
   \   00000058   000095E5           LDR      R0,[R5, #+0]
   \   0000005C   ........           BL       ??Count
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   E60100EF           SWI      +486
    336                      SetCursorToMenuItem(data,0);
   \   0000006C   0010A0E3           MOV      R1,#+0
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   C40100EF           SWI      +452
    337                      RefreshGUI();            
   \   00000078   960100EF           SWI      +406
    338                      break;
    339                    }
    340                }
    341              }
    342            }
    343            return 0;
   \                     ??onKey_1:
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   3080BDE8           POP      {R4,R5,PC}       ;; return
    344          }
    345          

   \                                 In segment CODE, align 4, keep-with-next
    346          void MenuList::gHook(void *data, int cmd)
    347          {
    348           /* if (cmd == TI_CMD_FOCUS)
    349            {
    350              DisableIDLETMR();
    351              int n = list->Count();//DownloadHandler::Top->GetNumOfDownloads();
    352              Menu_SetItemCountDyn(data, n);
    353            }*/
    354          }
   \                     ??gHook:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    355          
    356          

   \                                 In segment CODE, align 4, keep-with-next
    357          void MenuList::ItemHandler(void * data, int curitem, void * unk)
    358          {
   \                     ??ItemHandler:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
    359            WSHDR * ws1, * ws;
    360            void * item = AllocMLMenuItem(data);
   \   0000000C   0400A0E1           MOV      R0,R4
   \   00000010   190200EF           SWI      +537
   \   00000014   0070A0E1           MOV      R7,R0
    361          
    362          //  ws1=AllocMenuWS(data,strlen("error")+4);
    363            MNU *fl;
    364            
    365             //for(int i=0 ; i<qlist->Count(); i++)
    366          //     ShowMSG(1,(int)qlist->Items(curitem-1)->name); 
    367            fl = list->Items(curitem);//FindFLISTtByN(curitem);
   \   00000018   ........           LDR      R0,??DataTable5  ;; list
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   ........           BL       ??Items
   \   00000028   0080A0E1           MOV      R8,R0
    368          //  ShowMSG(1,(int)fl->name);
    369            ws = AllocWS(64);  
   \   0000002C   4000A0E3           MOV      R0,#+64
   \   00000030   250100EF           SWI      +293
   \   00000034   0090A0E1           MOV      R9,R0
    370            if(fl && fl->name)
   \   00000038   000058E3           CMP      R8,#+0
   \   0000003C   04009815           LDRNE    R0,[R8, #+4]
   \   00000040   00005013           CMPNE    R0,#+0
   \   00000044   0D00000A           BEQ      ??ItemHandler_1
    371            {
    372              ws1=AllocMenuWS(data,64);
   \   00000048   4010A0E3           MOV      R1,#+64
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   980100EF           SWI      +408
   \   00000054   0060A0E1           MOV      R6,R0
    373              CutWSTR(ws1,0);
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   260100EF           SWI      +294
    374              ///ascii2ws(ws1,fl->name);
    375              wsprintf(ws1,"%s", fl->name);
   \   00000060   042098E5           LDR      R2,[R8, #+4]
   \   00000064   161F8FE2           ADR      R1,??ItemHandler_2  ;; "%s"
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   240100EF           SWI      +292
    376              wsprintf(ws,fl->dat);
   \   00000070   0C1098E5           LDR      R1,[R8, #+12]
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   240100EF           SWI      +292
   \   0000007C   090000EA           B        ??ItemHandler_3
    377            }
    378            else
    379             {
    380               ws = AllocMenuWS(data,10);
   \                     ??ItemHandler_1:
   \   00000080   0A10A0E3           MOV      R1,#+10
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   980100EF           SWI      +408
    381               wsprintf(ws,"error");
   \   0000008C   34109FE5           LDR      R1,??ItemHandler_2+0x4  ;; `?<Constant "error">`
   \   00000090   0090A0E1           MOV      R9,R0
   \   00000094   240100EF           SWI      +292
    382               wsInsertChar(ws,2,1);
   \   00000098   0120A0E3           MOV      R2,#+1
   \   0000009C   0210A0E3           MOV      R1,#+2
   \   000000A0   0900A0E1           MOV      R0,R9
   \   000000A4   1D0000EF           SWI      +29
    383             } 
    384            
    385              SetMLMenuItemText(data, item, ws1, ws, curitem);
   \                     ??ItemHandler_3:
   \   000000A8   20002DE9           PUSH     {R5}
   \   000000AC   0930A0E1           MOV      R3,R9
   \   000000B0   0620A0E1           MOV      R2,R6
   \   000000B4   0710A0E1           MOV      R1,R7
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   180200EF           SWI      +536
    386          /*  WSHDR * ws1, * ws2, * ws3;
    387            void * item = AllocMLMenuItem(data);
    388            //Download * dl = DownloadHandler::Top->GetDownloadbyN(curitem);
    389            if(dl && dl->file_name)
    390            {
    391              ws1 = AllocMenuWS(data, strlen(dl->file_name) + 1);
    392              str_2ws(ws1, dl->file_name, strlen(dl->file_name));
    393            }
    394            else
    395            {
    396              ws1 = AllocMenuWS(data, 32);
    397              ascii2ws(ws1, "No name");
    398            }
    399            ws2 = AllocMenuWS(data, 32);
    400          
    401            SetMLMenuItemText(data, item, ws1, ws2, curitem);*/
    402          }
   \   000000C0   F183BDE8           POP      {R0,R4-R9,PC}    ;; return
   \                     ??ItemHandler_2:
   \   000000C4   25730000           DC8      "%s",+0
   \   000000C8   ........           DC32     `?<Constant "error">`
    403          
    404          

   \                                 In segment CODE, align 4, keep-with-next
    405          void MenuList::Show()
    406          {  
   \                     ??Show:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    407            patch_header(&list_hdr);
   \   00000004   68509FE5           LDR      R5,??Show_1      ;; list_hdr
    408            
    409            list_sk[0].lgp_id = (int)"Delete";
   \   00000008   68609FE5           LDR      R6,??Show_1+0x4  ;; `?<Constant "Delete">`
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   B000C5E1           STRH     R0,[R5, #+0]
   \   00000018   1800A0E3           MOV      R0,#+24
   \   0000001C   B200C5E1           STRH     R0,[R5, #+2]
   \   00000020   888100EF           SWI      +33160
   \   00000024   010040E2           SUB      R0,R0,#+1
   \   00000028   B400C5E1           STRH     R0,[R5, #+4]
   \   0000002C   8A8100EF           SWI      +33162
   \   00000030   170080E2           ADD      R0,R0,#+23
   \   00000034   B600C5E1           STRH     R0,[R5, #+6]
    410            list_sk[1].lgp_id = (int)"Exit";
   \   00000038   080086E2           ADD      R0,R6,#+8
   \   0000003C   200085E5           STR      R0,[R5, #+32]
    411            
    412            gui_id = CreateMultiLinesMenu(NULL, NULL, &list_desc, &list_hdr, NULL, list->Count());
   \   00000040   ........           LDR      R0,??DataTable5  ;; list
   \   00000044   186085E5           STR      R6,[R5, #+24]
   \   00000048   000090E5           LDR      R0,[R0, #+0]
   \   0000004C   ........           BL       ??Count
   \   00000050   01002DE9           PUSH     {R0}
   \   00000054   0530A0E1           MOV      R3,R5
   \   00000058   102086E2           ADD      R2,R6,#+16
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   170200EF           SWI      +535
   \   0000006C   000084E5           STR      R0,[R4, #+0]
    413          }
   \   00000070   7380BDE8           POP      {R0,R1,R4-R6,PC}  ;; return
   \                     ??Show_1:
   \   00000074   ........           DC32     list_hdr
   \   00000078   ........           DC32     `?<Constant "Delete">`
    414          

   \                                 In segment CODE, align 4, keep-with-next
    415          MenuList::MenuList()
    416          {
    417            Active = this;
   \                     ??MenuList:
   \   00000000   ........           LDR      R1,??DataTable6  ;; ??Active
   \   00000004   000081E5           STR      R0,[R1, #+0]
    418            gui_id = NULL;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   001080E5           STR      R1,[R0, #+0]
    419          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
    420          

   \                                 In segment CODE, align 4, keep-with-next
    421          MenuList::~MenuList()
    422          {
    423          }
   \                     `?~MenuList`:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for list_hdr>`:
   \   00000000   000000000000       DC16 0, 0, 0, 0
   \              0000        
   \   00000008   000000000000       DC32 0H, 0, 2147483647
   \              0000FFFFFF7F
   \                     `?<Initializer for list_sk>`:
   \   00000014   18000000           DC16 24, 0
   \   00000018   00000000           DC32 0
   \   0000001C   01000000           DC16 1, 0
   \   00000020   00000000           DC32 0
   \   00000024   3D000000           DC16 61, 0
   \   00000028   FBC0FF7F           DC32 2147467515

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for list_skt>`:
   \   00000000   ........0000       DC32 list_sk, 0
   \              0000        

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   257300             DC8 "%s"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "error">`:
   \   00000000   6572726F7200       DC8 "error"
   \   00000006   0000               DC8 0, 0

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs CList &CList::new CList()
   \                     `??new CList`:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0800A0E3           MOV      R0,#+8
   \   00000008   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0010A013           MOVNE    R1,#+0
   \   00000014   00108015           STRNE    R1,[R0, #+0]
   \   00000018   04108015           STRNE    R1,[R0, #+4]
   \   0000001C   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void CList::delete ~CList(CList *)
   \                     `??delete ~CList`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   1080BD08           POPEQ    {R4,PC}
   \   0000000C   ........           BL       ??FreeList
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs MenuList &MenuList::new MenuList()
   \                     `??new MenuList`:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0400A0E3           MOV      R0,#+4
   \   00000008   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   ........           LDRNE    R2,??DataTable6  ;; ??Active
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   00008215           STRNE    R0,[R2, #+0]
   \   0000001C   00108015           STRNE    R1,[R0, #+0]
   \   00000020   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void MenuList::delete ~MenuList(MenuList *)
   \                     `??delete ~MenuList`:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0080BD08           POPEQ    {PC}
   \   0000000C   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   00000010   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     list

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     ??Active

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     CList::CList()                     0
     CList::Change(_LIST_STRUCT *, int)
                                       20
     CList::Change(char *, int)        20
     CList::Count()                     0
     CList::Delete(_LIST_STRUCT *, int)
                                       28
     CList::FreeList()                  8
     CList::Insert(_LIST_STRUCT *, int)
                                       20
     CList::Insert(char *, int)        16
     CList::Items(int)                  0
     CList::Swap(int, int)             32
     CList::add(_LIST_STRUCT *)         0
     CList::add(char *)                20
     CList::add(int)                   20
     CList::delete ~CList(CList *)      8
     CList::new CList()                 4
     CList::~CList()                    4
     MenuList::ItemHandler(void *, int, void *)
                                       32
     MenuList::MenuList()               0
     MenuList::Show()                  24
     MenuList::delete ~MenuList(MenuList *)
                                        4
     MenuList::gHook(void *, int)       0
     MenuList::new MenuList()           4
     MenuList::onKey(void *, GUI_MSG *)
                                       12
     MenuList::~MenuList()              0
     list_ghook(void *, int)            0
     list_itemhndl(void *, int, void *)
                                        4
     list_keyhook(void *, GUI_MSG *)
                                        4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _d                                3
     CList::add(_LIST_STRUCT *)       68
     CList::add(char *)               84
     CList::add(int)                 100
     CList::Insert(_LIST_STRUCT *, int)
                                     116
     CList::Insert(char *, int)       56
     CList::Delete(_LIST_STRUCT *, int)
                                     228
     CList::Swap(int, int)           196
     CList::Change(_LIST_STRUCT *, int)
                                     152
     CList::Change(char *, int)       80
     CList::FreeList()                48
     CList::CList()                   16
     CList::~CList()                   4
     CList::Items(int)                44
     CList::Count()                   36
     MenuList::Active                  4
     list_ghook(void *, int)           4
     list_itemhndl(void *, int, void *)
                                      24
     list_keyhook(void *, GUI_MSG *)
                                      20
     list_hdr                         44
     list_skt                          8
     list_softkeys                    12
     ?<Constant "Delete">             64
     MenuList::onKey(void *, GUI_MSG *)
                                     132
     MenuList::gHook(void *, int)      4
     MenuList::ItemHandler(void *, int, void *)
                                     204
     MenuList::Show()                124
     MenuList::MenuList()             20
     MenuList::~MenuList()             4
     ?<Initializer for list_hdr>      44
     ?<Initializer for list_skt>       8
     ?<Constant "%s">                  3
     ?<Constant "error">               8
     CList::new CList()               32
     CList::delete ~CList(CList *)    28
     MenuList::new MenuList()         36
     MenuList::delete ~MenuList(MenuList *)
                                      20
     ??DataTable5                      4
     ??DataTable6                      4
      Others                         180

 
 2 044 bytes in segment CODE
    90 bytes in segment DATA_C
    52 bytes in segment DATA_I
    52 bytes in segment DATA_ID
     4 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 1 888 bytes of CODE  memory (+ 180 bytes shared)
   142 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: none
