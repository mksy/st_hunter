##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Jul/2010  17:20:49 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\pasha\elf\_MY_PROJECT_\marks\main.c               #
#    Command line    =  D:\pasha\elf\_MY_PROJECT_\marks\main.c -D NEWSGOLD   #
#                       -D ELKA -lC D:\pasha\elf\_MY_PROJECT_\marks\Release_ #
#                       ELKA\List\ -o D:\pasha\elf\_MY_PROJECT_\marks\Releas #
#                       e_ELKA\Obj\ -s9 --no_unroll --cpu_mode arm --endian  #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --eec++ --dlib_config                  #
#                       "D:\pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\LIB\dl5tpainl8n.h" -I                #
#                       "D:\pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  D:\pasha\elf\_MY_PROJECT_\marks\Release_ELKA\List\ma #
#                       in.lst                                               #
#    Object file     =  D:\pasha\elf\_MY_PROJECT_\marks\Release_ELKA\Obj\mai #
#                       n.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

D:\pasha\elf\_MY_PROJECT_\marks\main.c
      1          #include "..\inc\swilib.h"
      2          #include "language.h"
      3          #include "main.h"
      4          #include "File.h"
      5          #include "List.h"
      6          
      7          CList *list;
      8          MenuList *mlist;
      9          
     10          CSM_DESC icsmd;
     11          int id_ed;
     12          int draw_id;
     13          
     14          unsigned int MAINCSM_ID = 0;
     15          unsigned int MAINGUI_ID = 0;
     16          const int minus11=-11;
     17          
     18          const char per_t[]="%t";
     19          const char per_s[]="%s";
     20          const char empty_str[]="";
     21          
     22          char hdr_txt[64];
     23          int readonly=0;
     24          
     25          int total_char=0;
     26          char dir[128];//="0:\\mark";
     27          
     28          EDITCONTROL ec;
     29          
     30          volatile int prev_itemcount;
     31          
     32          //MNU *mnutop;
     33          #define mnutop list->gettop();
     34          
     35          GBSTMR mytmr;
     36          
     37          int DrawText(int i,MNU *fl);
     38          
     39          void about()
     40          {
     41            char s[128];
     42            snprintf(s,128,"Marks v0.2 Cpp\n(c)kluchnik\n%s %s",__DATE__,__TIME__);
     43            ShowMSG(2, (int)s);
     44          }
     45          
     46          void Message(char *s)
     47          {
     48            ShowMSG(1,(int)s);
     49          }
     50          
     51          void Message(unsigned long i)
     52          {
     53            char *s=(char*)malloc(64);
     54            sprintf(s,"%d",i);
     55            ShowMSG(1,(int)s);
     56            mfree(s);
     57          }
     58          
     59          int get_file_size(char* fname)
     60          {
     61            unsigned int err;
     62            FSTATS fs;
     63            if ((GetFileStats(fname,&fs,&err))==-1) return 0;
     64            return (fs.size);
     65          }
     66          
     67          //------------------------------------------//
     68          
     69          char *fdt2s(unsigned int time, char *buf)//Разберем дату и время
     70          {
     71            short y,M,d,h,m;//,s;
     72            y = (time >> 25) + 80;
     73            if (y>100) y -= 100;
     74            M = (time >> 21) & 0x0f;
     75            d = (time >> 16) & 0x1f;
     76          
     77            h = (time >> 11) & 0x1f;
     78            m = (time >> 5)  & 0x3f;
     79          
     80            sprintf(buf, "%.2d.%.2d.%.2d %.2d:%.2d", d,M,y,h,m);
     81            return buf;
     82          }
     83          
     84          
     85          int strcmp_nocase(const char *s, const char *d)
     86          {
     87            int cs;
     88            int ds;
     89            do
     90            {
     91              cs=*s++;
     92              if (cs&0x40) cs&=0xDF;
     93              ds=*d++;
     94              if (ds&0x40) ds&=0xDF;
     95              cs-=ds;
     96              if (cs) break;
     97            }
     98            while(ds);
     99            return(cs);
    100          }
    101          
    102          //------------------------------------------//
    103          
    104          void Add(const char *filename,const char *text,char *dt,int is_first)
    105          {
    106            MNU *fn = (MNU*)malloc(sizeof(MNU));
    107            fn->filename = (char*)malloc(strlen(filename)+1);
    108            fn->name=(char*)malloc(32);
    109            fn->text=(char*)malloc(strlen(text)+1);
    110            fn->dat=(char*)malloc(strlen(dt));
    111            
    112            strcpy(fn->filename,filename);
    113            strncpy(fn->name,text,32);
    114            strcpy(fn->text,text);
    115            strcpy(fn->dat,dt);
    116          
    117            fn->is_first = is_first;   
    118            fn->next=0;
    119            
    120            list->add(fn);
    121          }
    122          
    123          void ws2str(WSHDR *ws,char *s)
    124          {
    125            int i;
    126            for(i=0;i<ws->wsbody[0];i++)
    127             *(s+i)=char16to8(ws->wsbody[i+1]);
    128             *(s+i++)=0;
    129          }
    130          
    131          static const char *LoadTEXT(char *path)
    132          {
    133            unsigned int err; 
    134            int f; 
    135            char *buf;
    136            if((f = fopen(path,A_ReadOnly+A_BIN,P_READ,&err ))!=-1)
    137            {
    138              buf=(char*)malloc(get_file_size(path)); 
    139              buf[fread(f,buf,get_file_size(path),&err)]=0;        
    140            }
    141            fclose(f,&err); 
    142           return buf;
    143          }
    144          
    145          
    146          void LoadMark()//Ищем все файлы истории и сохраняем имена,текст и дату создания
    147          {
    148             Add("<Создать новую запись>","<Создать новую запись>","",1);//Добавляем в начало пункт
    149             DIR_ENTRY de;
    150             unsigned int err;
    151             char *s = (char*)malloc(32);
    152             char *path = (char*)malloc(256);
    153             if(!(isdir(dir,&err)))
    154             {
    155               mkdir(dir,&err);//Если директории нет,то создаем ее
    156               SetFileAttrib(dir,FA_HIDDEN,&err);
    157             }
    158             sprintf(path,per_s,dir);
    159             char *ptr = path+strlen(path)+1;
    160             strcat(path,"\\*.txt");
    161             if(FindFirstFile(&de,path,&err))
    162              {
    163               do
    164               {
    165                 strcpy(ptr,de.file_name);  
    166                 Add(de.file_name,LoadTEXT(path),fdt2s(de.create_date_time, s),0);
    167                 prev_itemcount++;
    168               }
    169               while(FindNextFile(&de,&err));
    170              }
    171             FindClose(&de,&err);
    172             mfree(path);
    173             mfree(s);
    174          }
    175          
    176          //------------------- Т9 ------------------//
    177          
    178          //Ключи для поиска по T9
    179          static const char table_T9Key[257]=
    180          "11111111111111111111111111111111"
    181          "10001**0***0000*012345678900***0"
    182          "0222333444555666777788899991*110"
    183          "122233344455566677778889999111*1"
    184          "11111111111111111111111111111111"
    185          "11111111311111111111111131111111"
    186          "22223333444455566677778888899999"
    187          "22223333444455566677778888899999";
    188          
    189          
    190          char T9Key[32];
    191          char _sk_r[16];
    192          char main_hdr_txt[64];
    193          
    194          MNU *FindBCFGByNS(int *i,int si)
    195          {
    196            MNU *t;
    197            t=(MNU *)mnutop;
    198            char *s;
    199            char *d;
    200            int c;
    201            while(t)
    202            {
    203             s=T9Key;
    204             d=t->name;
    205             while(c=*s++)
    206             {
    207              if(c!=table_T9Key[*d++]) goto L_NOT9;
    208             }
    209             if(t->is_first==si)
    210              {
    211                if(!(*i)) return(t);
    212                (*i)--;
    213              }
    214           L_NOT9:
    215              t=t->next;
    216            }
    217            return(t);
    218          }
    219          
    220          #define IS_ANY 0xFFFFFFFF
    221          
    222          MNU *FindFLISTtByN(int n)
    223          {
    224            MNU *fl;
    225            fl=FindBCFGByNS(&n,1); if ((!n)&&(fl)) return(fl);
    226            fl=FindBCFGByNS(&n,0); if ((!n)&&(fl)) return(fl);
    227            return fl;
    228          }
    229          
    230          void ClearT9Key(void)
    231          {
    232            zeromem(T9Key,sizeof(T9Key));
    233          }
    234          
    235          int CountBCFG(void)
    236          {
    237            int l=-1;
    238          //  FindBCFGByNS(&l,IS_ANY);
    239            FindBCFGByNS(&l,1);
    240            FindBCFGByNS(&l,0);
    241            l=-1-l;
    242            return l;
    243          }
    244          
    245          //----------------------------------//
    246          
    247          void UpdateHeader(void)
    248          {
    249            if (strlen(T9Key))
    250            {
    251              strcpy(main_hdr_txt,"Ввод T9:");
    252              strcat(main_hdr_txt,T9Key);
    253              strcpy(_sk_r,"<C");
    254            }
    255            else
    256            {
    257              strcpy(main_hdr_txt,"Заметки");
    258              strcpy(_sk_r,"Выход");
    259            }
    260          }
    261          
    262          void AddT9Key(int chr)
    263          {
    264            int l=strlen(T9Key);
    265            if(l<(sizeof(T9Key)-1))
    266            {
    267              T9Key[l]=chr;
    268            }
    269          }
    270          
    271          void BackSpaceT9(void)
    272          {
    273            int l=strlen(T9Key);
    274            if(l)
    275            {
    276              l--;
    277              T9Key[l]=0;
    278            }
    279          }
    280          
    281          static void RecountMenuBCFG(void *data)
    282          {
    283            int i;
    284            UpdateHeader();
    285            if (!id_ed) return; //Нечего считать
    286            i=CountBCFG();
    287            if(i!=prev_itemcount)
    288            {
    289              prev_itemcount=i;
    290              Menu_SetItemCountDyn(data,i);
    291            }
    292            SetCursorToMenuItem(data,0);
    293            if (IsGuiOnTop(id_ed)) RefreshGUI();
    294          }
    295          
    296          //------------------------Создаем список--------------------------//
    297          
    298          void bm_menu_iconhnd(void *data, int curitem, void *unk);
    299          HEADER_DESC bm_menuhdr={0,0,0,0,NULL,(int)main_hdr_txt,LGP_NULL};
    300          const int menusoftkeys[]={0,1,2};
    301          
    302          const SOFTKEY_DESC menu_sk2[]=
    303          {
    304            {0x0004,0x0000,(int)"Удалить"},
    305            {0x0001,0x0000,(int)_sk_r},
    306            {0x003D,0x0000,(int)LGP_DOIT_PIC}
    307          };
    308          
    309          const SOFTKEYSTAB menu_skt2=
    310          {
    311            menu_sk2,0
    312          };
    313          
    314          int item=0;
    315          
    316          void bm_menu_ghook(void *data, int cmd)
    317          {
    318            if (cmd==0x0A)
    319            {
    320              DisableIDLETMR();
    321          //    Menu_SetItemCountDyn(data,CountBCFG());
    322            }
    323          };
    324          
    325          MNU *FindByN(int n)
    326          {
    327            MNU *fl;
    328            int i=0;
    329            int j=0;
    330            int k = list->Count(); //GetFListN2();
    331            fl = list->gettop();  //(MNU *)mnutop;
    332            j=k-n-1;
    333            for(i=0; i<j && (fl) ;i++)
    334             {
    335               fl=fl->next;
    336             }
    337            return fl;
    338          }
    339          
    340          void DelItem(MNU *fl/*char *filename*/)
    341          {
    342            if(!fl) return;
    343            //fl->filename
    344            char *s = (char*)malloc(256);
    345            unsigned int err;
    346            sprintf(s,"%s\\%s",dir,fl->filename);
    347            unlink(s,&err);
    348            
    349            //list->FreeList();
    350          //  LoadMark();
    351            list->Delete(fl);
                                  ^
Error[Pe165]: too few arguments in function call

  const char per_t[]="%t";
             ^
"D:\pasha\elf\_MY_PROJECT_\marks\main.c",18  Warning[Pe177]: variable "per_t"
          was declared but never referenced
    352          //  Message("File deleted");
    353           // if(IsGuiOnTop(id_ed)) RefreshGUI();
    354            mfree(s);
    355          }
    356          
    357          
    358          int bm_menu_onkey2(void *data, GUI_MSG *msg)
    359          {
    360           int i;
    361           i=GetCurMenuItem(data);
    362           int k=msg->gbsmsg->submess;
    363           MNU *fl;
    364           fl=FindFLISTtByN(i);
    365           if(msg->keys==0x3D)
    366           {
    367             if(fl)
    368             {
    369              if(strlen(T9Key))
    370              {
    371                ClearT9Key();
    372                RecountMenuBCFG(data);
    373              }
    374              readonly=0; 
    375              DrawText(NULL,fl);
    376             }
    377             return (-1);
    378           }
    379           /*
    380           if(k==LEFT_SOFT)  
    381           {
    382             delname=malloc(strlen(fl->filename));
    383             strcpy(delname,fl->filename);
    384             changefile=fl;
    385             ShowMainMenu();
    386           }*/
    387           if(k==LEFT_BUTTON) return 1;
    388           if(k=='*') about(); 
    389           if(k=='#')         
    390           {
    391             DelItem(fl);
    392           } 
    393          
    394           if (msg->gbsmsg->msg==KEY_DOWN)
    395            {
    396              int key=msg->gbsmsg->submess;
    397              if((key>='0')&&(key<='9'))
    398              {
    399                AddT9Key(key);
    400                RecountMenuBCFG(data);
    401                return(-1);
    402              }
    403            }
    404            
    405            if (msg->keys==1 || msg->keys==RED_BUTTON)
    406            {
    407              if (strlen(T9Key))
    408              {
    409                BackSpaceT9();
    410                RecountMenuBCFG(data);
    411                return(-1);
    412              }
    413            }
    414          return 0;
    415          }
    416          
    417          const ML_MENU_DESC bmmenu=//Bookmarks
    418          {
    419            8,bm_menu_onkey2,bm_menu_ghook,NULL,
    420            menusoftkeys,
    421            &menu_skt2,
    422            0x10,
    423            bm_menu_iconhnd,
    424            NULL,   //Items
    425            NULL,   //Procs
    426            0,   //n
    427            1  
    428          };
    429          
    430          void bm_menu_iconhnd(void *data, int curitem, void *unk)
    431          {
    432            WSHDR *ws1;
    433            WSHDR *ws;
    434            void *item=AllocMLMenuItem(data);
    435            MNU *fl;
    436            
    437            fl=FindFLISTtByN(curitem);
    438            ws=AllocWS(strlen(fl->dat));  
    439            if(fl->name)
    440            {
    441              ws1=AllocMenuWS(data,strlen(fl->name)+4);
    442              CutWSTR(ws1,0);
    443              ascii2ws(ws1,fl->name);
    444              if(fl->is_first==1)
    445              {
    446                wsInsertChar(ws1,0x0007,1);
    447                wsInsertChar(ws1,0xE008,1);
    448               }
    449               wsprintf(ws,per_s,fl->dat);
    450            }
    451            else
    452             {
    453              ws=AllocMenuWS(data,10);
    454              wsprintf(ws,"error");
    455              wsInsertChar(ws,2,1);
    456             }    
    457            SetMLMenuItemText(data, item, ws1, ws, curitem);
    458          }
    459          
    460          int create()
    461          {
    462            int i;
    463            i=CountBCFG();
    464            prev_itemcount=i;
    465            UpdateHeader();
    466            patch_header(&bm_menuhdr);
    467            return id_ed=CreateMultiLinesMenu(0,0,&bmmenu,&bm_menuhdr,0,i);
    468          }
    469          
    470          char *GetDate()
    471          {
    472            TDate date;
    473            TTime time;
    474            GetDateTime(&date,&time);
    475            char *s = (char*)malloc(64);
    476            sprintf(s,"%02d-%02d-%02d_%02d:%02d",date.day,date.month,date.year-2000,time.hour,time.min);
    477            return s;
    478          }
    479          
    480          //--------------------------------Редактор--------------------------------//
    481          
    482          char *cmp;
    483          MNU *FindFileByName(char *name)
    484          {
    485            MNU *fl;
    486            for(int k=0;k<list->Count()/*GetFListN2()*/;k++)//Ищем имя файла
    487            {
    488             fl=FindFLISTtByN(k);
    489             if(strcmp(cmp,fl->filename)==0) break;
    490             }
    491            return fl;
    492          }
    493          
    494          HEADER_DESC disk_prop_hdr={0,0,0,0,NULL,(int)hdr_txt,LGP_NULL};
    495          int empty_onkey(GUI *data, GUI_MSG *msg)
    496          {
    497            int k=msg->gbsmsg->submess;
    498            MNU *fl;
    499            MNU *nw;
    500            unsigned long num=0x0;
    501            unsigned int err;
    502            char *ss;
    503            WSHDR *ws;
    504            int last_name=0;
    505          
    506            if(msg->keys==0xFFF && readonly==1)//Если нажали "Сохранить" и у нас режим редактирования
    507            {
    508              EDITCONTROL ec;
    509              fl=FindFileByName(cmp);//Ищем запись по имени файла
    510              ExtractEditControl(data,1,&ec);	
    511              ws=ec.pWS;
    512              void *data=FindGUIbyId(id_ed,NULL);
    513              if(fl->is_first)//Если нажали "Создать заметку"
    514              {
    515                for(int t=0;t<list->Count();t++)//Ищем последнюю запись чтобы узнать последнее имя,на всяк случай...
    516                {
    517                  nw = FindFLISTtByN(t);
    518                  num = strtoul(nw->filename,0,16);
    519                  if(num > last_name)
    520                    last_name = num;
    521                }
    522                num=last_name;
    523                num+=0x01;
    524                sprintf(nw->filename,"%02X.txt",num);
    525                nw->text = (char*)malloc(ws->wsbody[0]);
    526                ws2str(ws,nw->text);
    527                SaveMark(nw->filename,nw->text);
    528                
    529                readonly=0;//Сохраняемся и открываем созданную запись.
    530                Add(nw->filename,nw->text,(char*)empty_str,0);
    531                GeneralFuncF1(1);
    532              }
    533              else
    534              {
    535               ss=(char*)malloc(256);
    536               sprintf(ss,"%s\\%s",dir,fl->filename);
    537               unlink(ss,&err);
    538               fl->text=(char*)malloc(ws->wsbody[0]);
    539               ws2str(ws,fl->text); 
    540               SaveMark(fl->filename,fl->text);
    541               strncpy(fl->name,fl->text,32);
    542               
    543               readonly=0;//Сохраняемся и переходим в режим реадонли:)
    544          //     RecountMenuBCFG(data);
    545               GeneralFuncF1(1);
    546               DrawText(NULL,fl);
    547              }
    548            }
    549          
    550           if(msg->gbsmsg->msg==KEY_DOWN &&( ( (k>='0' && k<='9')||(k==ENTER_BUTTON) ) && (readonly==0)))
    551           {
    552             fl=FindFileByName(cmp);
    553             readonly=1;
    554             GeneralFunc_flag1(draw_id,1);
    555             DrawText(NULL,fl);
    556           }
    557           
    558           if(msg->gbsmsg->msg==KEY_DOWN  || msg->gbsmsg->msg==LONG_PRESS )
    559           {
    560             if((k==UP_BUTTON && readonly==0) && item!=0)
    561              {
    562                GeneralFunc_flag1(draw_id,1);
    563                int y;
    564                int num;
    565                y=strtoul(cmp,0,16);
    566                if(y>0x01) y-=0x01;
    567                else 
    568                {
    569                 for(int t=0;t</*GetFListN2()*/list->Count();t++)
    570                  {
    571                    //Ищем последнюю запись чтобы узнать последнее имя.
    572                    nw=FindFLISTtByN(t);
    573                    num=strtoul(nw->filename,0,16);
    574                    if(num>y) 
    575                      y=num;
    576                  }
    577                }
    578                for(int k=0;k<list->Count();k++)//Ищем имя файла
    579                {       
    580                  fl=FindFLISTtByN(k);       
    581                  if(y==strtoul(fl->filename,0,16)) break;
    582                }
    583          
    584                DrawText(NULL,fl); 
    585              }
    586             
    587             if((k==DOWN_BUTTON && readonly==0) && item!=0)
    588              {
    589                GeneralFunc_flag1(draw_id,1);
    590                int y;
    591                int num;
    592                int first,last=0;
    593                y=strtoul(cmp,0,16);
    594                for(int t=0;t<list->Count();t++)
    595                  {
    596                    //Ищем последнюю запись чтобы узнать последнее имя.
    597                    nw=FindFLISTtByN(t);
    598                    num=strtoul(nw->filename,0,16);
    599                    if(num>last) 
    600                      last=num;
    601                  }
    602                nw=FindFLISTtByN(1);//имя файла первой записи
    603                first=strtoul(nw->filename,0,16);
    604                if(y<last) y+=0x01;
    605                else y=first;
    606                
    607                for(int k=0;k<list->Count();k++)//Ищем имя файла
    608                {       
    609                 fl=FindFLISTtByN(k);       
    610                 if(y==strtoul(fl->filename,0,16)) break;
    611                }
    612          
    613                DrawText(NULL,fl); 
    614              }
    615             
    616             if(k==GREEN_BUTTON)
    617             {
    618                int  y=strtoul(cmp,0,16);
    619                for(int k=0;k<list->Count();k++)//Ищем имя файла
    620                {       
    621                 fl=FindFLISTtByN(k);       
    622                 if(y==strtoul(fl->filename,0,16)) break;
    623                }
    624                SaveMark(fl->filename,fl->text);
    625             }
    626           }
    627          return(0);
    628          }
    629          
    630          const SOFTKEY_DESC sk[]=
    631          {
    632            {0x0004,0x0000,(int)""},
    633            {0x0001,0x0000,(int)_sk_r},
    634            {0x003D,0x0000,(int)LGP_DOIT_PIC}
    635          };
    636          
    637          SOFTKEYSTAB skt={ sk,0 };
    638          
    639          void empty_locret(void){}
    640          
    641          void empty_ghook(GUI *gui, int cmd)
    642          { 
    643            static SOFTKEY_DESC sk={0x0FFF,0x0000,(int)"Сохранить"};
    644            
    645            if(cmd==0xA)
    646            {
    647              DisableIDLETMR();   // Отключаем таймер выхода по таймауту
    648            }
    649            
    650            if(cmd==0x03)
    651            {
    652              void *data=FindGUIbyId(id_ed,NULL);
    653              RecountMenuBCFG(data);
    654            }
    655            
    656            if(cmd==7)
    657            {
    658              SetSoftKey(gui,&sk,SET_SOFT_KEY_N);
    659            }
    660          };
    661          
    662          
    663          INPUTDIA_DESC edit_desc=//Редактирование
    664          {
    665            1,
    666            empty_onkey,
    667            empty_ghook,
    668            (void *)empty_locret,
    669            0,
    670            &skt,
    671            {0,0,0,0},
    672            FONT_SMALL,
    673            100,
    674            101,
    675            0,
    676            0,
    677            0x40000000
    678          };
    679           
    680          //------------------------------------//
    681          
    682          static void SaveMark(char *name,char *text)//Сохраняем в каталог
    683          {
    684            unsigned int err;
    685            int f;
    686            char *p=(char*)malloc(strlen(dir)+64);
    687            sprintf(p,"%s\\%s",dir,name);
    688            SetFileAttrib(p,0x0000,&err);
    689            if((f=fopen(p,A_Create+A_ReadWrite+A_BIN+A_Truncate,P_WRITE,&err))!=-1)
    690             {
    691              fwrite(f,text,strlen(text)+1,&err);
    692              ShowMSG(1,(int)LG_FILESAVE);
    693             }
    694            else ShowMSG(1,(int)LG_NOTSAVE);
    695            SetFileAttrib(p,FA_READONLY,&err);
    696            fclose(f,&err);
    697          }
    698          
    699          //------------------------------------//
    700          
    701          int DrawText(int i,MNU *fn)//собственно эдитконтроль
    702          {
    703            ClearT9Key();
    704            EDITC_OPTIONS ec_options;
    705            PrepareEditControl(&ec);
    706          
    707            void *ma=malloc_adr();
    708            void *eq=AllocEQueue(ma, mfree_adr());
    709            WSHDR *ws=AllocWS(strlen(fn->text));
    710            MNU *fl;
    711            for(item=0 ; item<list->Count() ; item++)//Ищем имя файла
    712              {
    713                fl=FindFLISTtByN(item);
    714                if( (strtoul(fn->filename,0,16)) == (strtoul(fl->filename,0,16)) ) break;
    715              }
    716          //  fl=FindFLISTtByN(i);
    717           // ShowMSG(1,(int)fl->filename);
    718            cmp=(char*)malloc(strlen(fl->filename));
    719            strcpy(cmp,fl->filename);
    720            
    721            if(fl->is_first==1) sprintf(hdr_txt,"%s","Новая запись");
    722            else
    723              if(!readonly) sprintf(hdr_txt,"%d. %s",item,fl->dat);//Если открываем для просмотра в режим реадонли,то выводим в заголовке дату
    724            else sprintf(hdr_txt,"%d. %s", item,"Редактирование");//Иначе просто слово Заметки:)
    725          
    726            if(fl->is_first!=1) ascii2ws(ws,fl->text);//Если открываем запись,то выводим текст
    727            else readonly=1;//Если создаем,то сразу открываем редактирование
    728          
    729            ConstructEditControl(&ec,readonly?ECT_NORMAL_TEXT:ECT_READ_ONLY,0x40,ws,16384);//16 кило думаю хватит :)
    730            PrepareEditCOptions(&ec_options);
    731            SetFontToEditCOptions(&ec_options,1);
    732            CopyOptionsToEditControl(&ec,&ec_options);
    733            AddEditControlToEditQend(eq,&ec,ma);
    734          
    735            patch_header(&disk_prop_hdr);
    736            patch_input(&edit_desc);      
    737          
    738            FreeWS(ws);
    739            return draw_id=CreateInputTextDialog(&edit_desc,&disk_prop_hdr,eq,1,0);
    740          }
    741          
    742          //-------------------------------------------------------------------------------------//
    743          
    744          void maincsm_oncreate(CSM_RAM *data)
    745          {
    746            list = new CList;
    747            mlist = new MenuList;
    748            LoadMark();
    749            mlist->Show();
    750            MAIN_CSM *csm=(MAIN_CSM*)data;
    751            csm->gui_id=create();
    752          }
    753          
    754          void Killer(void)
    755          {
    756            extern void seqkill(void *data, void(*next_in_seq)(CSM_RAM *), void *data_to_kill, void *seqkiller);
    757            extern void *ELF_BEGIN;
    758          }
    759          
    760          void maincsm_onclose(CSM_RAM *csm)
    761          {
    762            delete mlist;
    763            delete list;  
    764            SUBPROC((void *)Killer);
    765          }
    766          
    767          int maincsm_onmessage(CSM_RAM *data, GBS_MSG *msg)
    768          {
    769            MAIN_CSM *csm=(MAIN_CSM*)data;
    770            if (msg->msg==MSG_GUI_DESTROYED)
    771            {
    772              if ((int)msg->data0==csm->gui_id)
    773              {
    774                {
    775          	csm->csm.state=-3;
    776                }
    777              }
    778            } 
    779            return(1);
    780          }
    781          
    782          unsigned short maincsm_name_body[140];
    783          
    784          const struct
    785          {
    786            CSM_DESC maincsm;
    787            WSHDR maincsm_name;
    788          }MAINCSM =
    789          {
    790            {
    791            maincsm_onmessage,
    792            maincsm_oncreate,
    793          #ifdef NEWSGOLD
    794            0,
    795            0,
    796            0,
    797            0,
    798          #endif
    799            maincsm_onclose,
    800            sizeof(MAIN_CSM),
    801            1,
    802            &minus11
    803            },
    804            {
    805              maincsm_name_body,
    806              NAMECSM_MAGIC1,
    807              NAMECSM_MAGIC2,
    808              0x0,
    809              139
    810            }
    811          };
    812          
    813          
    814          void UpdateCSMname(void)
    815          { 
    816            wsprintf((WSHDR *)(&MAINCSM.maincsm_name),"Marks");
    817          }
    818          
    819          int maincsm_id;
    820          int main(char *exename, char *fname)
    821          { 
    822            strcpy(dir,exename);
    823            for(int i=strlen(dir);dir[i]!='\\';i--) dir[i]=0;
    824            strcat(dir,"mark");
    825          
    826          //  LoadMark();
    827          
    828            char dummy[sizeof(MAIN_CSM)];
    829            UpdateCSMname();
    830            LockSched();
    831            maincsm_id=CreateCSM(&MAINCSM.maincsm,dummy,0);
    832            UnlockSched();
    833           return 0;
    834          }
    835          
    836          
    837          
    838          //-----------------------Edit chat---------------------------//
    839          
    840          
    841          typedef struct
    842          {
    843            unsigned short u;
    844            char dos;
    845            char win;
    846            char koi8;
    847          } TUNICODE2CHAR;
    848          
    849          const TUNICODE2CHAR unicode2char[]=
    850          {
    851            // CAPITAL Cyrillic letters (base)
    852            0x410,0x80,0xC0,0xE1, // А
    853            0x411,0x81,0xC1,0xE2, // Б
    854            0x412,0x82,0xC2,0xF7, // В
    855            0x413,0x83,0xC3,0xE7, // Г
    856            0x414,0x84,0xC4,0xE4, // Д
    857            0x415,0x85,0xC5,0xE5, // Е
    858            0x416,0x86,0xC6,0xF6, // Ж
    859            0x417,0x87,0xC7,0xFA, // З
    860            0x418,0x88,0xC8,0xE9, // И
    861            0x419,0x89,0xC9,0xEA, // Й
    862            0x41A,0x8A,0xCA,0xEB, // К
    863            0x41B,0x8B,0xCB,0xEC, // Л
    864            0x41C,0x8C,0xCC,0xED, // М
    865            0x41D,0x8D,0xCD,0xEE, // Н
    866            0x41E,0x8E,0xCE,0xEF, // О
    867            0x41F,0x8F,0xCF,0xF0, // П
    868            0x420,0x90,0xD0,0xF2, // Р
    869            0x421,0x91,0xD1,0xF3, // С
    870            0x422,0x92,0xD2,0xF4, // Т
    871            0x423,0x93,0xD3,0xF5, // У
    872            0x424,0x94,0xD4,0xE6, // Ф
    873            0x425,0x95,0xD5,0xE8, // Х
    874            0x426,0x96,0xD6,0xE3, // Ц
    875            0x427,0x97,0xD7,0xFE, // Ч
    876            0x428,0x98,0xD8,0xFB, // Ш
    877            0x429,0x99,0xD9,0xFD, // Щ
    878            0x42A,0x9A,0xDA,0xFF, // Ъ
    879            0x42B,0x9B,0xDB,0xF9, // Ы
    880            0x42C,0x9C,0xDC,0xF8, // Ь
    881            0x42D,0x9D,0xDD,0xFC, // Э
    882            0x42E,0x9E,0xDE,0xE0, // Ю
    883            0x42F,0x9F,0xDF,0xF1, // Я
    884            // CAPITAL Cyrillic letters (additional)
    885            0x402,'_',0x80,'_', // _ .*.*
    886            0x403,'_',0x81,'_', // _ .*.*
    887            0x409,'_',0x8A,'_', // _ .*.*
    888            0x40A,'_',0x8C,'_', // _ .*.*
    889            0x40C,'_',0x8D,'_', // _ .*.*
    890            0x40B,'_',0x8E,'_', // _ .*.*
    891            0x40F,'_',0x8F,'_', // _ .*.*
    892            0x40E,0xF6,0xA1,'_', // Ў ...*
    893            0x408,0x4A,0xA3,0x4A, // _ .*.*
    894            0x409,0x83,0xA5,0xBD, // _ .*..
    895            0x401,0xF0,0xA8,0xB3, // Ё
    896            0x404,0xF2,0xAA,0xB4, // Є
    897            0x407,0xF4,0xAF,0xB7, // Ї
    898            0x406,0x49,0xB2,0xB6, // _ .*..
    899            0x405,0x53,0xBD,0x53, // _ .*.*
    900            // SMALL Cyrillic letters (base)
    901            0x430,0xA0,0xE0,0xC1, // а
    902            0x431,0xA1,0xE1,0xC2, // б
    903            0x432,0xA2,0xE2,0xD7, // в
    904            0x433,0xA3,0xE3,0xC7, // г
    905            0x434,0xA4,0xE4,0xC4, // д
    906            0x435,0xA5,0xE5,0xC5, // е
    907            0x436,0xA6,0xE6,0xD6, // ж
    908            0x437,0xA7,0xE7,0xDA, // з
    909            0x438,0xA8,0xE8,0xC9, // и
    910            0x439,0xA9,0xE9,0xCA, // й
    911            0x43A,0xAA,0xEA,0xCB, // к
    912            0x43B,0xAB,0xEB,0xCC, // л
    913            0x43C,0xAC,0xEC,0xCD, // м
    914            0x43D,0xAD,0xED,0xCE, // н
    915            0x43E,0xAE,0xEE,0xCF, // о
    916            0x43F,0xAF,0xEF,0xD0, // п
    917            0x440,0xE0,0xF0,0xD2, // р
    918            0x441,0xE1,0xF1,0xD3, // с
    919            0x442,0xE2,0xF2,0xD4, // т
    920            0x443,0xE3,0xF3,0xD5, // у
    921            0x444,0xE4,0xF4,0xC6, // ф
    922            0x445,0xE5,0xF5,0xC8, // х
    923            0x446,0xE6,0xF6,0xC3, // ц
    924            0x447,0xE7,0xF7,0xDE, // ч
    925            0x448,0xE8,0xF8,0xDB, // ш
    926            0x449,0xE9,0xF9,0xDD, // щ
    927            0x44A,0xEA,0xFA,0xDF, // ъ
    928            0x44B,0xEB,0xFB,0xD9, // ы
    929            0x44C,0xEC,0xFC,0xD8, // ь
    930            0x44D,0xED,0xFD,0xDC, // э
    931            0x44E,0xEE,0xFE,0xC0, // ю
    932            0x44F,0xEF,0xFF,0xD1, // я
    933            // SMALL Cyrillic letters (additional)
    934            0x452,'_',0x90,'_', // _ .*.*
    935            0x453,'_',0x83,'_', // _ .*.*
    936            0x459,'_',0x9A,'_', // _ .*.*
    937            0x45A,'_',0x9C,'_', // _ .*.*
    938            0x45C,'_',0x9D,'_', // _ .*.*
    939            0x45B,'_',0x9E,'_', // _ .*.*
    940            0x45F,'_',0x9F,'_', // _ .*.*
    941            0x45E,0xF7,0xA2,'_', // ў ...*
    942            0x458,0x6A,0xBC,0x6A, // _ .*.*
    943            0x491,0xA3,0xB4,0xAD, // _ .*..
    944            0x451,0xF1,0xB8,0xA3, // ё
    945            0x454,0xF3,0xBA,0xA4, // є
    946            0x457,0xF5,0xBF,0xA7, // ї
    947            0x456,0x69,0xB3,0xA6, // _ .*..
    948            0x455,0x73,0xBE,0x73, // _ .*.*
    949            0x0A0,'_',0xA0,0x20, // space .*..
    950            0x0A4,'_',0xA4,0xFD, // ¤   .*..
    951            0x0A6,'_',0xA6,'_', // ¦   .*.*
    952            0x0B0,0xF8,0xB0,0x9C, // °
    953            0x0B7,0xFA,0xB7,0x9E, // ·
    954            // 0x2022,,0x95,0x95, //    .*..
    955            // 0x2116,0xFC,0xB9,0x23, // №   ...*
    956            // 0x2219,,0xF9,0x9E, //    .*..
    957            // 0x221A,0xFB,,0x96, // v   ..*.
    958            // 0x25A0,0xFE,,0x94, // ¦
    959            0x0000,0,0,0
    960          };
    961          
    962          const char wintranslation[128]=
    963          {
    964            0x5F,0x5F,0x27,0x5F,0x22,0x3A,0xC5,0xD8,0x5F,0x25,0x5F,0x3C,0x5F,0x5F,0x5F,0x5F,
    965            0x5F,0x27,0x27,0x22,0x22,0x07,0x2D,0x2D,0x5F,0x54,0x5F,0x3E,0x5F,0x5F,0x5F,0x5F,
    966            0xFF,0xF6,0xF7,0x5F,0xFD,0x83,0xB3,0x15,0xF0,0x63,0xF2,0x3C,0xBF,0x2D,0x52,0xF4,
    967            0xF8,0x2B,'I' ,'i' ,0xA3,0xE7,0x14,0xFA,0xF1,0xFC,0xF3,0x3E,0x5F,0x5F,0x5F,0xF5,
    968            0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
    969            0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
    970            0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
    971            0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF
    972          };
    973          const unsigned short dos2unicode[128]=
    974          {
    975            0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,
    976            0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,
    977            0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,
    978            0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,
    979            0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,
    980            0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,
    981            0x002D,0x002D,0x002D,0x00A6,0x002B,0x00A6,0x00A6,0x00AC,
    982            0x00AC,0x00A6,0x00A6,0x00AC,0x002D,0x002D,0x002D,0x00AC,
    983            0x004C,0x002B,0x0054,0x002B,0x002D,0x002B,0x00A6,0x00A6,
    984            0x004C,0x0433,0x00A6,0x0054,0x00A6,0x003D,0x002B,0x00A6,
    985            0x00A6,0x0054,0x0054,0x004C,0x004C,0x002D,0x0433,0x002B,
    986            0x002B,0x002D,0x002D,0x002D,0x002D,0x00A6,0x00A6,0x002D,
    987            0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,
    988            0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F,
    989            0x0401,0x0451,0x0404,0x0454,0x0407,0x0457,0x040E,0x045E,
    990            0x00B0,0x2022,0x00B7,0x0076,0x2116,0x00A4,0x00A6,0x00A0
    991          };
    992          const char koi8translation[128]=
    993          {
    994            0x5F,0x5F,0x27,0x5F,0x22,0x3A,0xC5,0xD8,0x5F,0x25,0x5F,0x3C,0x5F,0x5F,0x5F,0x5F,
    995            0x5F,0x27,0x27,0x22,0x22,0x07,0x2D,0x2D,0x5F,0x54,0x5F,0x3E,0x5F,0x5F,0x5F,0x5F,
    996            0xFF,0xF6,0xF7,0xF1,0xF3,0x5F,'i' ,0xF5,0xF0,0x63,0xF2,0x3C,0xBF,0xA3,0x52,0xF4,
    997            0xF8,0x2B,0x5F,0xF0,0xF2,0xE7,'I' ,0xF4,0xF1,0xFC,0xF3,0x3E,0x5F,0x83,0x5F,0xF5,
    998            
    999            0xEE,0xA0,0xA1,0xE6,0xA4,0xA5,0xE4,0xA3,0xE5,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,
   1000            0xAF,0xEF,0xE0,0xE1,0xE2,0xE3,0xA6,0xA2,0xEC,0xEB,0xA7,0xE8,0xED,0xE9,0xE7,0xEA,
   1001            0x9E,0x80,0x81,0x96,0x84,0x85,0x94,0x83,0x95,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,
   1002            0x8F,0x9F,0x90,0x91,0x92,0x93,0x86,0x82,0x9C,0x9B,0x87,0x98,0x9D,0x99,0x97,0x9A
   1003          };
   1004          
   1005          #pragma inline
   1006          unsigned int char16to8(unsigned int c)
   1007          {
   1008            const TUNICODE2CHAR *p=unicode2char;
   1009            unsigned int i;
   1010            if (c<128) return(c);
   1011            while((i=p->u))
   1012            {
   1013              if (c==i)
   1014              {
   1015                return(p->win);
   1016              }
   1017              p++;
   1018            }
   1019            c&=0xFF;
   1020            if (c<32) return(' ');
   1021            return(c);
   1022          }
   1023          
   1024          unsigned int char8to16(int c, int type)
   1025          {
   1026            if (c>=128)
   1027            {
   1028              switch(type)
   1029              {
   1030              case 1:
   1031                //Win->Dos
   1032                c=wintranslation[c-128];
   1033                break;
   1034              case 2:
   1035                //Koi8->Dos
   1036                c=koi8translation[c-128];
   1037                break;
   1038              }
   1039              if (c<128) return(c);
   1040              return(dos2unicode[c-128]);
   1041            }
   1042            return(c);
   1043          }
   1044          
   1045          /*
   1046          void ascii2ws(WSHDR *ws, const char *s)
   1047          {
   1048            char c;
   1049            CutWSTR(ws,0);
   1050            while((c=*s++))
   1051            {
   1052              wsAppendChar(ws,char8to16(c,1));
   1053            }
   1054          }*/
   1055          unsigned int win2unicode(int letter)
   1056          {
   1057            if (letter<168) goto L_ENG;
   1058            if (letter==168) goto L_BIG_YO;
   1059            letter-=168;
   1060            if (letter<24) goto L_UKR;
   1061            if (letter>87) goto L_ENG;
   1062          //L_RUS:
   1063            letter-=8;
   1064            goto L_ADD_400;
   1065          L_UKR:
   1066            switch(letter)
   1067            {
   1068            case 0x02:
   1069              letter=0x04;
   1070              break;
   1071            case 10:
   1072              letter=6;
   1073              break;
   1074            case 11:
   1075              letter=0x56;
   1076              break;
   1077            case 16:
   1078              letter=0x51;
   1079              break;
   1080            case 18:
   1081              letter=0x54;
   1082              break;
   1083            case 23:
   1084              letter=0x57;
   1085              break;
   1086            default:
   1087              goto L_ENG;
   1088            }
   1089            goto L_ADD_400;
   1090          L_BIG_YO:
   1091            letter=0x01;
   1092          L_ADD_400:
   1093            return (letter+0x400);
   1094            
   1095          L_ENG: return (letter);
   1096          }
   1097          
   1098          
   1099          void ascii2ws(WSHDR *ws, const char *s)
   1100          {
   1101            char c;
   1102            CutWSTR(ws,0);
   1103            while((c=*s++))
   1104            {
   1105              total_char++;
   1106              wsAppendChar(ws,win2unicode(c));
   1107            }
   1108          }
   1109          
   1110          void koi2ws(WSHDR *ws, const char *s)
   1111          {
   1112            char c;
   1113            CutWSTR(ws,0);
   1114            while((c=*s++))
   1115            {
   1116              total_char++;
   1117              wsAppendChar(ws,char8to16(c,2));
   1118            }
   1119          }
   1120          
   1121          void win1251_2ws(WSHDR *ws, const char *s)
   1122          {
   1123            char c;
   1124            CutWSTR(ws,0);
   1125            while((c=*s++))
   1126            {
   1127              total_char++;
   1128              wsAppendChar(ws,char16to8(c));
   1129            }
   1130          }
   1131          
   1132          

Errors: 1
Warnings: 1
