##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    19/Dec/2008  01:45:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  K:\Pasha\elf\_MY_PROJECT_\TED_w\convert_format.c     #
#    Command line    =  K:\Pasha\elf\_MY_PROJECT_\TED_w\convert_format.c -D  #
#                       NEWSGOLD -D ELKA -lC K:\Pasha\elf\_MY_PROJECT_\TED_w #
#                       \Release_ELKA\List\ -o K:\Pasha\elf\_MY_PROJECT_\TED #
#                       _w\Release_ELKA\Obj\ -s9 --no_unroll                 #
#                       --no_clustering --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None -I "K:\Pasha\Embedded Workbench 4.0       #
#                       Evaluation2\ARM\INC\" --inline_threshold=9           #
#    List file       =  K:\Pasha\elf\_MY_PROJECT_\TED_w\Release_ELKA\List\co #
#                       nvert_format.lst                                     #
#    Object file     =  K:\Pasha\elf\_MY_PROJECT_\TED_w\Release_ELKA\Obj\con #
#                       vert_format.r79                                      #
#                                                                            #
#                                                                            #
##############################################################################

K:\Pasha\elf\_MY_PROJECT_\TED_w\convert_format.c
      1          #include "..\inc\swilib.h"
      2          
      3          /*void my_memset(void *dst, int v, unsigned int len)
      4          {
      5            char *d=(char *)dst;
      6            if (len)
      7            {
      8              do
      9              {
     10                *d++=v;
     11              }
     12              while(--len);
     13            }
     14          }*/
     15          #define my_memset memset
     16          
     17          extern unsigned long curline; //Наружная переменная, счетчик строк
     18          extern unsigned int max_x; //Наружная переменная - макс. размер строки
     19          
     20          extern char *dstk;
     21          extern char *ustk;
     22          
     23          extern unsigned int FL_loader(int fin, unsigned int p);
     24          extern unsigned int FL_saver(int fs, unsigned int p);
     25          
     26          extern int win_dos_koi;
     27          extern const char wintranslation[];
     28          extern const char koi8translation[];
     29          

   \                                 In segment DATA_C, align 4, align-sorted
     30          static const char ctype[128]=
   \                     ctype:
   \   00000000   020101010102       DC8 2, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1
   \              010102030101
   \              010102010101
   \              0102010101  
   \   00000017   010101030203       DC8 1, 1, 1, 3, 2, 3, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 1, 1
   \              020202020101
   \              010102010102
   \              0301010101  
   \   0000002E   020100000000       DC8 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000000000  
   \   00000045   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000000000  
   \   0000005C   000000000101       DC8 0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 2, 2, 2, 2
   \              010201010101
   \              010103020302
   \              0202020202  
   \   00000073   020202020200       DC8 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00          
     31          {
     32            2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
     33            1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
     34            2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
     35            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     36            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     37            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
     38            1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
     39            2,2,2,2,2,2,2,2, 0,0,0,0,0,0,0,0,
     40          };
     41          

   \                                 In segment CODE, align 4, keep-with-next
     42          int GetCharType_x(int c)
     43          {
     44            if (c==' ') return(4); //Пробел
   \                     GetCharType_x:
   \   00000000   200050E3           CMP      R0,#+32
   \   00000004   0400A003           MOVEQ    R0,#+4
   \   00000008   1EFF2F01           BXEQ     LR
     45            if (c<32) return(5); //Конец строки
   \   0000000C   200050E3           CMP      R0,#+32
   \   00000010   0500A0B3           MOVLT    R0,#+5
   \   00000014   1EFF2FB1           BXLT     LR
     46            if ((c=='i')||(c=='I')) return 2; //Гласная для украинского ;)
   \   00000018   690050E3           CMP      R0,#+105
   \   0000001C   49005013           CMPNE    R0,#+73
   \   00000020   0200A003           MOVEQ    R0,#+2
   \   00000024   1EFF2F01           BXEQ     LR
     47            if (c<128) return(0); //Не русская буква
   \   00000028   800050E3           CMP      R0,#+128
   \   0000002C   0D0000BA           BLT      ??GetCharType_x_0
     48            switch(win_dos_koi)
   \   00000030   ........           LDR      R1,??DataTable1  ;; win_dos_koi
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   011051E2           SUBS     R1,R1,#+1
   \   0000003C   0200000A           BEQ      ??GetCharType_x_1
   \   00000040   011051E2           SUBS     R1,R1,#+1
   \   00000044   0200000A           BEQ      ??GetCharType_x_2
   \   00000048   040000EA           B        ??GetCharType_x_3
     49            {
     50            case 1:
     51              //Win->Dos
     52              c=wintranslation[c-128];
   \                     ??GetCharType_x_1:
   \   0000004C   2C109FE5           LDR      R1,??GetCharType_x_4  ;; wintranslation
   \   00000050   000000EA           B        ??GetCharType_x_5
     53              break;
     54            case 2:
     55              //Koi8->Dos
     56              c=koi8translation[c-128];
   \                     ??GetCharType_x_2:
   \   00000054   28109FE5           LDR      R1,??GetCharType_x_4+0x4  ;; koi8translation
   \                     ??GetCharType_x_5:
   \   00000058   010080E0           ADD      R0,R0,R1
   \   0000005C   800050E5           LDRB     R0,[R0, #-128]
     57              break;
     58            }
     59            if (c<128) return(0); //Не русская буква
   \                     ??GetCharType_x_3:
   \   00000060   800050E3           CMP      R0,#+128
   \   00000064   010000AA           BGE      ??GetCharType_x_6
   \                     ??GetCharType_x_0:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   1EFF2FE1           BX       LR
     60            return(ctype[c-128]);
   \                     ??GetCharType_x_6:
   \   00000070   10109FE5           LDR      R1,??GetCharType_x_4+0x8  ;; ctype
   \   00000074   010080E0           ADD      R0,R0,R1
   \   00000078   800050E5           LDRB     R0,[R0, #-128]
   \   0000007C   1EFF2FE1           BX       LR               ;; return
   \                     ??GetCharType_x_4:
   \   00000080   ........           DC32     wintranslation
   \   00000084   ........           DC32     koi8translation
   \   00000088   ........           DC32     ctype
     61          }
     62          
     63          unsigned int def_code (void);
     64          
     65          //Процедура форматирования текста

   \                                 In segment CODE, align 4, keep-with-next
     66          unsigned int ConvertFormat(int fin,int fs,int fmt)
     67          {
   \                     ConvertFormat:
   \   00000000   F74F2DE9           PUSH     {R0-R2,R4-R11,LR}
   \   00000004   43DF4DE2           SUB      SP,SP,#+268
     68            unsigned int c0;
     69            unsigned int c1=1; //Начать с пропуска символов
     70            unsigned int c2=1;
     71            unsigned int c3=32; //Начать с абзаца, раз у нас форматирование ;)
     72          
     73            //unsigned int last_space;
     74          
     75            unsigned int sl;
     76          
     77            register unsigned int s;
     78            register unsigned int d;
     79            char ct[256]; //Массив для описания типа символов
     80          
     81            char *ds=dstk;
     82            register char *us=ustk;
   \   00000008   E8039FE5           LDR      R0,??ConvertFormat_0  ;; ustk
     83          
     84            extern unsigned int STKSZ50;
     85          
     86            int maxstk=STKSZ50;
     87          
     88            d=0;
     89            us[d]=0;
     90            sl=0;
     91            //last_space=0xFFFF;
     92            s=FL_loader(fin,0xFFFFFFFF);
     93          
     94            if (win_dos_koi==0xFF) win_dos_koi=def_code ();
   \   0000000C   ........           LDR      R9,??DataTable1  ;; win_dos_koi
   \   00000010   006090E5           LDR      R6,[R0, #+0]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   \   0000001C   ........           LDR      R1,??DataTable5  ;; dstk
   \   00000020   00A0A0E3           MOV      R10,#+0
   \   00000024   001091E5           LDR      R1,[R1, #+0]
   \   00000028   0A00A0E1           MOV      R0,R10
   \   0000002C   04108DE5           STR      R1,[SP, #+4]
   \   00000030   C4139FE5           LDR      R1,??ConvertFormat_0+0x4  ;; STKSZ50
   \   00000034   0080A0E1           MOV      R8,R0
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   0140A0E3           MOV      R4,#+1
   \   00000040   08108DE5           STR      R1,[SP, #+8]
   \   00000044   0000C6E5           STRB     R0,[R6, #+0]
   \   00000048   0010E0E1           MVN      R1,R0
   \   0000004C   0C019DE5           LDR      R0,[SP, #+268]
   \   00000050   2050A0E3           MOV      R5,#+32
   \   00000054   ........           _BLF     FL_loader,??FL_loader??rA
   \   00000058   0070A0E1           MOV      R7,R0
   \   0000005C   000099E5           LDR      R0,[R9, #+0]
   \   00000060   FF0050E3           CMP      R0,#+255
   \   00000064   0100001A           BNE      ??ConvertFormat_1
   \   00000068   ........           BL       def_code
   \   0000006C   000089E5           STR      R0,[R9, #+0]
     95          
     96            //Подготавливаем массив ct
     97            c0=0;
   \                     ??ConvertFormat_1:
   \   00000070   0090A0E3           MOV      R9,#+0
     98            do
     99            {
    100              ct[c0]=GetCharType_x(c0);
   \                     ??ConvertFormat_2:
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   ........           BL       GetCharType_x
   \   0000007C   0C108DE2           ADD      R1,SP,#+12
   \   00000080   0100C9E7           STRB     R0,[R9, +R1]
    101            }
    102            while((++c0)!=sizeof(ct));
   \   00000084   019089E2           ADD      R9,R9,#+1
   \   00000088   400F59E3           CMP      R9,#+256
   \   0000008C   F8FFFF1A           BNE      ??ConvertFormat_2
    103          
    104          #define GetCharType(VAR) (ct[VAR])
    105          
    106            for(;;)
    107            {
    108              c0=c1;
   \                     ??ConvertFormat_3:
   \   00000090   0490A0E1           MOV      R9,R4
    109              c1=c2;
   \   00000094   00409DE5           LDR      R4,[SP, #+0]
    110              c2=c3;
   \   00000098   00508DE5           STR      R5,[SP, #+0]
   \   0000009C   030000EA           B        ??ConvertFormat_4
    111            LSKIP1:
    112              c3=ds[s++];
    113              if (s>=maxstk) s=FL_loader(fin,s);
    114              if (c3==9) c3=' '; //Замена табуляции на пробел
   \                     ??ConvertFormat_5:
   \   000000A0   2050A0E3           MOV      R5,#+32
   \                     ??ConvertFormat_6:
   \   000000A4   00009DE5           LDR      R0,[SP, #+0]
   \   000000A8   200050E3           CMP      R0,#+32
   \   000000AC   1600001A           BNE      ??ConvertFormat_7
   \                     ??ConvertFormat_4:
   \   000000B0   04009DE5           LDR      R0,[SP, #+4]
   \   000000B4   0050D7E7           LDRB     R5,[R7, +R0]
   \   000000B8   08009DE5           LDR      R0,[SP, #+8]
   \   000000BC   017087E2           ADD      R7,R7,#+1
   \   000000C0   000057E1           CMP      R7,R0
   \   000000C4   0300003A           BCC      ??ConvertFormat_8
   \   000000C8   0C019DE5           LDR      R0,[SP, #+268]
   \   000000CC   0710A0E1           MOV      R1,R7
   \   000000D0   ........           _BLF     FL_loader,??FL_loader??rA
   \   000000D4   0070A0E1           MOV      R7,R0
   \                     ??ConvertFormat_8:
   \   000000D8   090055E3           CMP      R5,#+9
    115              if (c3==1) c3=' '; //Замена служ. символов
   \   000000DC   01005513           CMPNE    R5,#+1
   \   000000E0   EEFFFF0A           BEQ      ??ConvertFormat_5
    116              if ((c3==' ')&&(c2==' ')) goto LSKIP1; //Пропуск пробелов
   \   000000E4   200055E3           CMP      R5,#+32
   \   000000E8   EDFFFF0A           BEQ      ??ConvertFormat_6
    117              if ((c3==13)&&(ds[s]==10)) s++; //0D0A->0D
   \   000000EC   0D0055E3           CMP      R5,#+13
   \   000000F0   0500001A           BNE      ??ConvertFormat_7
   \   000000F4   04009DE5           LDR      R0,[SP, #+4]
   \   000000F8   0000D7E7           LDRB     R0,[R7, +R0]
   \   000000FC   0A0050E3           CMP      R0,#+10
   \   00000100   0800001A           BNE      ??ConvertFormat_9
   \   00000104   017087E2           ADD      R7,R7,#+1
   \   00000108   060000EA           B        ??ConvertFormat_9
    118              if ((c3==10)&&(ds[s]==13)) s++; //0A0D->0A
   \                     ??ConvertFormat_7:
   \   0000010C   0A0055E3           CMP      R5,#+10
   \   00000110   0400001A           BNE      ??ConvertFormat_9
   \   00000114   04009DE5           LDR      R0,[SP, #+4]
    119              if (c3==10) c3=13; //0A->0D
   \   00000118   0D50A0E3           MOV      R5,#+13
   \   0000011C   0000D7E7           LDRB     R0,[R7, +R0]
   \   00000120   0D0050E3           CMP      R0,#+13
   \   00000124   01708702           ADDEQ    R7,R7,#+1
    120              if (c0==0) goto LEOF; //Конец текста
   \                     ??ConvertFormat_9:
   \   00000128   06008AE0           ADD      R0,R10,R6
   \   0000012C   01108AE2           ADD      R1,R10,#+1
   \   00000130   000059E3           CMP      R9,#+0
   \   00000134   0E00001A           BNE      ??ConvertFormat_10
    121              if (fmt==1)
    122              {
    123                if ((c0>' ')&&(c1=='-')&&(c2==13)&&(c3>' '))
    124                {
    125          	//Удаление переноса
    126          	c1=1;
    127          	c2=1;
    128          	goto LSYM;
    129                }
    130                if ((c0>' ')&&(c1==13)&&(c2>' '))
    131                {
    132          	//Замена перевода строки на пробел между словами
    133          	c1=' ';
    134          	goto LSYM;
    135                }
    136              }
    137              if (c0==13)
    138              {
    139                //Во всех других случаях перенос строки - это абзац
    140                //last_space=0xFFFF;
    141                sl=0;
    142                d=FL_saver(fs,d); //Сливаем не слитое
    143                us[d++]=0; //Конец строки
    144                curline++;
    145                if ((c1>' ')&&(fmt==2))
    146                {
    147          	us[d++]=' '; //Если сл. символ - буква, добавляем отступ
    148          	sl++;
    149                }
    150                continue;
    151              }
    152            LSYM:
    153              if (c0!=1)
    154              {
    155                us[d]=c0;
    156                //if ((c0==' ')&&sl) last_space=d; //Запоминаем последний пробел
    157                d++;
    158                sl++;
    159                if (sl>max_x)
    160                {
    161          	//Слишком длинная строка, ищем, куда вставить перенос
    162          	unsigned int pp=d+2; //Начинаем с конца c учетом доп. символов
    163          	unsigned int pg1=0xFFFFFFFF;
    164          	unsigned int pg2=0xFFFFFFFF;
    165          	int c;
    166          	us[d]=c1;
    167          	us[d+1]=c2;
    168          	us[d+2]=c3;
    169          	for(;;)
    170          	{
    171          	  c=GetCharType(us[pp]);
    172          	  if ((c==5)&&(pp<d))
    173          	  {
    174          	    //Нет подходящих пробелов, режем по живому ;)
    175          	  L_CUT:
    176          	    d--;
    177          	    d=FL_saver(fs,d);
    178          	    us[d++]=0;
    179          	    us[d++]=c0;
    180          	    sl=1;
    181          	    break;
    182          	  }
    183          	  if ((c==4)&&(pp<d))
    184          	  {
    185          	    //Режем по пробелу
    186          	    if (us[pp-1]<2) goto L_CUT; //Первый пробел не обрезаем
    187          	    us[pp]=0; //Обрезаем по пробелу и признак форматирования
    188          	    sl=(d-pp)-1;
    189          	    d=FL_saver(fs,d); //Сливаем не слитое
    190          	    //last_space=0xFFFF;
    191          	    break;
    192          	  }
    193          	  if ((c<1)||(c>3))
    194          	  {
    195          	    pg1=0xFFFFFFFF; //Новое слово
    196          	    pg2=0xFFFFFFFF;
    197          	  }
    198          	  if (c==2)
    199          	  {
    200          	    pg2=pg1;
    201          	    pg1=pp;
    202          	    if (pg2!=0xFFFFFFFF)
    203          	    {
    204          	      //Нашли 2 гласных
    205          	      unsigned int pm=(pg2+pg1+1)>>1;
    206          	      if (GetCharType(us[pm])==3) pm++; //Если нельзя отрывать букву
    207          	      c=GetCharType(us[pm-2]);
    208          	      if ((pm<(d-1))&&(c>0)&&(c<4))
    209          	      {
    210          		if (pm==pg2)
    211          		{
    212          		  //Если гласная непостредственно справа, проверяем не одна ли она
    213          		  c=GetCharType(us[pg2+1]);
    214          		  if ((c<1)||(c>3)) goto L_NOPERE;
    215          		}
    216          		{
    217          		  //memmove(us+(pm+2),us+pm,d-pm);
    218          		  unsigned int len=d-pm;
    219          		  if (len)
    220          		  {
    221          		    char *d=us+(pm+2)+len-1;
    222          		    char *s=us+pm+len-1;
    223          		    do
    224          		    {
    225          		      *d=*s;
    226          		      d--;
    227          		      s--;
    228          		    }
    229          		    while(--len);
    230          		  }
    231          		}
    232          		us[pm++]='-';
    233          		us[pm++]=0;
    234          		d+=2; //Т.к. вставили 2 символа
    235          		sl=(d-pm);
    236          		d=FL_saver(fs,d); //Сливаем не слитое
    237          		break;
    238          	      L_NOPERE:
    239          		;
    240          	      }
    241          	    }
    242          	  }
    243          	  pp--;
    244          	}
    245          	curline++;
    246                }
    247              }
    248            }
    249          LEOF:
    250            if (sl) //Не записана последняя строка
   \   00000138   000058E3           CMP      R8,#+0
   \   0000013C   0700000A           BEQ      ??ConvertFormat_11
    251            {
    252              us[d++]=0;
   \   00000140   01A0A0E1           MOV      R10,R1
    253              curline++;
   \   00000144   B4129FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   00000148   0020A0E3           MOV      R2,#+0
   \   0000014C   0020C0E5           STRB     R2,[R0, #+0]
   \   00000150   A8029FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   00000154   001091E5           LDR      R1,[R1, #+0]
   \   00000158   011081E2           ADD      R1,R1,#+1
   \   0000015C   001080E5           STR      R1,[R0, #+0]
    254            }
    255            d=FL_saver(fs,d); //Сливаем не слитое
    256            return(d);
   \                     ??ConvertFormat_11:
   \   00000160   10019DE5           LDR      R0,[SP, #+272]
   \   00000164   0A10A0E1           MOV      R1,R10
   \   00000168   ........           _BLF     FL_saver,??FL_saver??rA
   \   0000016C   46DF8DE2           ADD      SP,SP,#+280
   \   00000170   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??ConvertFormat_10:
   \   00000174   14219DE5           LDR      R2,[SP, #+276]
   \   00000178   010052E3           CMP      R2,#+1
   \   0000017C   1300001A           BNE      ??ConvertFormat_12
   \   00000180   210059E3           CMP      R9,#+33
   \   00000184   1100003A           BCC      ??ConvertFormat_12
   \   00000188   2D0054E3           CMP      R4,#+45
   \   0000018C   0800001A           BNE      ??ConvertFormat_13
   \   00000190   00209DE5           LDR      R2,[SP, #+0]
   \   00000194   0D0052E3           CMP      R2,#+13
   \   00000198   2600001A           BNE      ??ConvertFormat_14
   \   0000019C   210055E3           CMP      R5,#+33
   \   000001A0   2400003A           BCC      ??ConvertFormat_14
   \   000001A4   0140A0E3           MOV      R4,#+1
   \   000001A8   0130A0E3           MOV      R3,#+1
   \   000001AC   00308DE5           STR      R3,[SP, #+0]
   \   000001B0   200000EA           B        ??ConvertFormat_14
   \                     ??ConvertFormat_13:
   \   000001B4   0D0054E3           CMP      R4,#+13
   \   000001B8   1E00001A           BNE      ??ConvertFormat_14
   \   000001BC   00209DE5           LDR      R2,[SP, #+0]
   \   000001C0   210052E3           CMP      R2,#+33
   \   000001C4   1B00003A           BCC      ??ConvertFormat_14
   \   000001C8   2040A0E3           MOV      R4,#+32
   \   000001CC   190000EA           B        ??ConvertFormat_14
   \                     ??ConvertFormat_12:
   \   000001D0   0D0059E3           CMP      R9,#+13
   \   000001D4   1500001A           BNE      ??ConvertFormat_15
   \   000001D8   10019DE5           LDR      R0,[SP, #+272]
   \   000001DC   0A10A0E1           MOV      R1,R10
   \   000001E0   ........           _BLF     FL_saver,??FL_saver??rA
   \   000001E4   0010A0E3           MOV      R1,#+0
   \   000001E8   0610C0E7           STRB     R1,[R0, +R6]
   \   000001EC   0C129FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   000001F0   01A080E2           ADD      R10,R0,#+1
   \   000001F4   04029FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   000001F8   001091E5           LDR      R1,[R1, #+0]
   \   000001FC   0080A0E3           MOV      R8,#+0
   \   00000200   011081E2           ADD      R1,R1,#+1
   \   00000204   001080E5           STR      R1,[R0, #+0]
   \   00000208   210054E3           CMP      R4,#+33
   \   0000020C   9FFFFF3A           BCC      ??ConvertFormat_3
   \   00000210   14019DE5           LDR      R0,[SP, #+276]
   \   00000214   020050E3           CMP      R0,#+2
   \   00000218   9CFFFF1A           BNE      ??ConvertFormat_3
   \   0000021C   2000A0E3           MOV      R0,#+32
   \   00000220   0600CAE7           STRB     R0,[R10, +R6]
   \   00000224   01A08AE2           ADD      R10,R10,#+1
   \   00000228   0180A0E3           MOV      R8,#+1
   \   0000022C   97FFFFEA           B        ??ConvertFormat_3
   \                     ??ConvertFormat_15:
   \   00000230   010059E3           CMP      R9,#+1
   \   00000234   95FFFF0A           BEQ      ??ConvertFormat_3
   \                     ??ConvertFormat_14:
   \   00000238   0090C0E5           STRB     R9,[R0, #+0]
   \   0000023C   C0019FE5           LDR      R0,??ConvertFormat_0+0xC  ;; max_x
   \   00000240   01A0A0E1           MOV      R10,R1
   \   00000244   000090E5           LDR      R0,[R0, #+0]
   \   00000248   018088E2           ADD      R8,R8,#+1
   \   0000024C   080050E1           CMP      R0,R8
   \   00000250   8EFFFF2A           BCS      ??ConvertFormat_3
   \   00000254   06108AE0           ADD      R1,R10,R6
   \   00000258   0040C1E5           STRB     R4,[R1, #+0]
   \   0000025C   00309DE5           LDR      R3,[SP, #+0]
   \   00000260   02208AE2           ADD      R2,R10,#+2
   \   00000264   0000E0E3           MVN      R0,#+0
   \   00000268   0130C1E5           STRB     R3,[R1, #+1]
   \   0000026C   0250C1E5           STRB     R5,[R1, #+2]
   \   00000270   000000EA           B        ??ConvertFormat_16
   \                     ??ConvertFormat_17:
   \   00000274   012042E2           SUB      R2,R2,#+1
   \                     ??ConvertFormat_16:
   \   00000278   063082E0           ADD      R3,R2,R6
   \   0000027C   0010D3E5           LDRB     R1,[R3, #+0]
   \   00000280   0C808DE2           ADD      R8,SP,#+12
   \   00000284   08E0D1E7           LDRB     LR,[R1, +R8]
   \   00000288   01104AE2           SUB      R1,R10,#+1
   \   0000028C   05005EE3           CMP      LR,#+5
   \   00000290   0A00001A           BNE      ??ConvertFormat_18
   \   00000294   0A0052E1           CMP      R2,R10
   \   00000298   1900002A           BCS      ??ConvertFormat_19
   \                     ??ConvertFormat_20:
   \   0000029C   10019DE5           LDR      R0,[SP, #+272]
   \   000002A0   0180A0E3           MOV      R8,#+1
   \   000002A4   ........           _BLF     FL_saver,??FL_saver??rA
   \   000002A8   0010A0E3           MOV      R1,#+0
   \   000002AC   0610C0E7           STRB     R1,[R0, +R6]
   \   000002B0   010080E2           ADD      R0,R0,#+1
   \   000002B4   0690C0E7           STRB     R9,[R0, +R6]
   \   000002B8   01A080E2           ADD      R10,R0,#+1
   \   000002BC   470000EA           B        ??ConvertFormat_21
   \                     ??ConvertFormat_18:
   \   000002C0   04005EE3           CMP      LR,#+4
   \   000002C4   0A00001A           BNE      ??ConvertFormat_22
   \   000002C8   0A0052E1           CMP      R2,R10
   \   000002CC   0C00002A           BCS      ??ConvertFormat_19
   \   000002D0   010053E5           LDRB     R0,[R3, #-1]
   \   000002D4   020050E3           CMP      R0,#+2
   \   000002D8   EFFFFF3A           BCC      ??ConvertFormat_20
   \   000002DC   0000A0E3           MOV      R0,#+0
   \   000002E0   0000C3E5           STRB     R0,[R3, #+0]
   \   000002E4   02004AE0           SUB      R0,R10,R2
   \   000002E8   018040E2           SUB      R8,R0,#+1
   \   000002EC   0A10A0E1           MOV      R1,R10
   \   000002F0   370000EA           B        ??ConvertFormat_23
   \                     ??ConvertFormat_22:
   \   000002F4   01005EE3           CMP      LR,#+1
   \   000002F8   010000BA           BLT      ??ConvertFormat_19
   \   000002FC   04005EE3           CMP      LR,#+4
   \   00000300   000000BA           BLT      ??ConvertFormat_24
   \                     ??ConvertFormat_19:
   \   00000304   0000E0E3           MVN      R0,#+0
   \                     ??ConvertFormat_24:
   \   00000308   02005EE3           CMP      LR,#+2
   \   0000030C   D8FFFF1A           BNE      ??ConvertFormat_17
   \   00000310   00C0A0E1           MOV      R12,R0
   \   00000314   0200A0E1           MOV      R0,R2
   \   00000318   01007CE3           CMN      R12,#+1
   \   0000031C   D4FFFF0A           BEQ      ??ConvertFormat_17
   \   00000320   00308CE0           ADD      R3,R12,R0
   \   00000324   013083E2           ADD      R3,R3,#+1
   \   00000328   A330A0E1           LSR      R3,R3,#+1
   \   0000032C   0680D3E7           LDRB     R8,[R3, +R6]
   \   00000330   0CE08DE2           ADD      LR,SP,#+12
   \   00000334   0CB08DE2           ADD      R11,SP,#+12
   \   00000338   0E80D8E7           LDRB     R8,[R8, +LR]
   \   0000033C   030058E3           CMP      R8,#+3
   \   00000340   01308302           ADDEQ    R3,R3,#+1
   \   00000344   068083E0           ADD      R8,R3,R6
   \   00000348   02E058E5           LDRB     LR,[R8, #-2]
   \   0000034C   010053E1           CMP      R3,R1
   \   00000350   0BE0DEE7           LDRB     LR,[LR, +R11]
   \   00000354   C6FFFF2A           BCS      ??ConvertFormat_17
   \   00000358   01005EE3           CMP      LR,#+1
   \   0000035C   C4FFFFBA           BLT      ??ConvertFormat_17
   \   00000360   04005EE3           CMP      LR,#+4
   \   00000364   C2FFFFAA           BGE      ??ConvertFormat_17
   \   00000368   0C0053E1           CMP      R3,R12
   \   0000036C   0600001A           BNE      ??ConvertFormat_25
   \   00000370   06108CE0           ADD      R1,R12,R6
   \   00000374   0110D1E5           LDRB     R1,[R1, #+1]
   \   00000378   0BE0D1E7           LDRB     LR,[R1, +R11]
   \   0000037C   01005EE3           CMP      LR,#+1
   \   00000380   BBFFFFBA           BLT      ??ConvertFormat_17
   \   00000384   04005EE3           CMP      LR,#+4
   \   00000388   B9FFFFAA           BGE      ??ConvertFormat_17
   \                     ??ConvertFormat_25:
   \   0000038C   03005AE0           SUBS     R0,R10,R3
   \   00000390   0700000A           BEQ      ??ConvertFormat_26
   \   00000394   061080E0           ADD      R1,R0,R6
   \   00000398   011083E0           ADD      R1,R3,R1
   \   0000039C   012081E2           ADD      R2,R1,#+1
   \   000003A0   011041E2           SUB      R1,R1,#+1
   \                     ??ConvertFormat_27:
   \   000003A4   ........           LDRB     R9,[R1], #-1
   \   000003A8   010050E2           SUBS     R0,R0,#+1
   \   000003AC   ........           STRB     R9,[R2], #-1
   \   000003B0   FBFFFF1A           BNE      ??ConvertFormat_27
   \                     ??ConvertFormat_26:
   \   000003B4   2D00A0E3           MOV      R0,#+45
   \   000003B8   0000C8E5           STRB     R0,[R8, #+0]
   \   000003BC   013083E2           ADD      R3,R3,#+1
   \   000003C0   0000A0E3           MOV      R0,#+0
   \   000003C4   0600C3E7           STRB     R0,[R3, +R6]
   \   000003C8   02108AE2           ADD      R1,R10,#+2
   \   000003CC   030041E0           SUB      R0,R1,R3
   \   000003D0   018040E2           SUB      R8,R0,#+1
   \                     ??ConvertFormat_23:
   \   000003D4   10019DE5           LDR      R0,[SP, #+272]
   \   000003D8   ........           _BLF     FL_saver,??FL_saver??rA
   \   000003DC   00A0A0E1           MOV      R10,R0
   \                     ??ConvertFormat_21:
   \   000003E0   18109FE5           LDR      R1,??ConvertFormat_0+0x8  ;; curline
   \   000003E4   14009FE5           LDR      R0,??ConvertFormat_0+0x8  ;; curline
   \   000003E8   001091E5           LDR      R1,[R1, #+0]
   \   000003EC   011081E2           ADD      R1,R1,#+1
   \   000003F0   001080E5           STR      R1,[R0, #+0]
   \   000003F4   25FFFFEA           B        ??ConvertFormat_3
   \                     ??ConvertFormat_0:
   \   000003F8   ........           DC32     ustk
   \   000003FC   ........           DC32     STKSZ50
   \   00000400   ........           DC32     curline
   \   00000404   ........           DC32     max_x
    257          }
    258          
    259          //-------------------------------------------------------------
    260          // Автоматическое определение кодировки (по первой загрузке)
    261          //-------------------------------------------------------------
    262          /* Таблица сочетаний */
    263          

   \                                 In segment DATA_C, align 4, align-sorted
    264          static const unsigned char table_2s[128]={0xFF,0xFF,0xFF,0xC7,0xFE,0xBE,0xF7,0xFB,
   \                     table_2s:
   \   00000000   FFFFFFC7FEBE       DC8 255, 255, 255, 199, 254, 190, 247, 251, 253, 191, 247, 249, 252
   \              F7FBFDBFF7F9
   \              FC          
   \   0000000D   BEF180FFFFF7       DC8 190, 241, 128, 255, 255, 247, 187, 255, 255, 255, 207, 222, 191
   \              BBFFFFFFCFDE
   \              BF          
   \   0000001A   D108FFBFF1BF       DC8 209, 8, 255, 191, 241, 191, 255, 255, 255, 199, 29, 63, 127, 129
   \              FFFFFFC71D3F
   \              7F81        
   \   00000028   A7B6F282FFFF       DC8 167, 182, 242, 130, 255, 255, 117, 219, 252, 191, 215, 157, 255
   \              75DBFCBFD79D
   \              FF          
   \   00000035   AEFBDFFFFFFF       DC8 174, 251, 223, 255, 255, 255, 199, 132, 183, 243, 159, 255, 255
   \              C784B7F39FFF
   \              FF          
   \   00000042   FFDBFFBFFFFF       DC8 255, 219, 255, 191, 255, 255, 253, 191, 255, 255, 255, 255, 231
   \              FDBFFFFFFFFF
   \              E7          
   \   0000004F   C7849EF012BC       DC8 199, 132, 158, 240, 18, 188, 191, 240, 132, 164, 186, 16, 16, 164
   \              BFF084A4BA10
   \              10A4        
   \   0000005D   BEB888ACBFF7       DC8 190, 184, 136, 172, 191, 247, 10, 132, 134, 144, 8, 4, 0, 0, 3, 127
   \              0A8486900804
   \              0000037F    
   \   0000006D   FDF7C17DAE6F       DC8 253, 247, 193, 125, 174, 111, 203, 21, 61, 252, 0, 127, 125, 231
   \              CB153DFC007F
   \              7DE7        
   \   0000007B   C27FFDF7C3         DC8 194, 127, 253, 247, 195
    265          0xFD,0xBF,0xF7,0xF9,0xFC,0xBE,0xF1,0x80,0xFF,0xFF,0xF7,0xBB,0xFF,0xFF,0xFF,
    266          0xCF,0xDE,0xBF,0xD1,0x08,0xFF,0xBF,0xF1,0xBF,0xFF,0xFF,0xFF,0xC7,0x1D,0x3F,
    267          0x7F,0x81,0xA7,0xB6,0xF2,0x82,0xFF,0xFF,0x75,0xDB,0xFC,0xBF,0xD7,0x9D,0xFF,
    268          0xAE,0xFB,0xDF,0xFF,0xFF,0xFF,0xC7,0x84,0xB7,0xF3,0x9F,0xFF,0xFF,0xFF,0xDB,
    269          0xFF,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC7,0x84,0x9E,0xF0,
    270          0x12,0xBC,0xBF,0xF0,0x84,0xA4,0xBA,0x10,0x10,0xA4,0xBE,0xB8,0x88,0xAC,0xBF,
    271          0xF7,0x0A,0x84,0x86,0x90,0x08,0x04,0x00,0x00,0x03,0x7F,0xFD,0xF7,0xC1,0x7D,
    272          0xAE,0x6F,0xCB,0x15,0x3D,0xFC,0x00,0x7F,0x7D,0xE7,0xC2,0x7F,0xFD,0xF7,0xC3};
    273          
    274          /* =========================================================================
    275          Вспомогательная функция alt2num.
    276          Вход: a - код русской буквы в кодировке ALT.
    277          Выход: порядковый номер этой буквы (0-31).
    278          ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    279          unsigned int alt2num (int a)
    280          {
    281            if (a>=0xE0) a-=0x30;
   \                     alt2num:
   \   00000000   E00050E3           CMP      R0,#+224
   \   00000004   300040A2           SUBGE    R0,R0,#+48
    282            return (a&31);
   \   00000008   1F0000E2           AND      R0,R0,#0x1F
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    283          }
    284          /* =========================================================================
    285          Вспомогательная функция koi2num.
    286          Вход: a - код русской буквы в кодировке KOI.
    287          Выход: порядковый номер этой буквы (0-31).
    288          ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    289          unsigned int koi2num (int a)
    290          {
    291            static const unsigned char t[32]={30,0,1,22,4,5,20,3,21,8,9,10,11,12,13,14,15,31,
    292            16,17,18,19,6,2,28,27,7,24,29,25,23,26};
    293            return (t[a&31]);
   \                     koi2num:
   \   00000000   ........           LDR      R1,??DataTable7  ;; ??t
   \   00000004   1F0000E2           AND      R0,R0,#0x1F
   \   00000008   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    294          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??t:
   \   00000000   1E0001160405       DC8 30, 0, 1, 22, 4, 5, 20, 3, 21, 8, 9, 10, 11, 12, 13, 14, 15, 31, 16
   \              14031508090A
   \              0B0C0D0E0F1F
   \              10          
   \   00000013   11121306021C       DC8 17, 18, 19, 6, 2, 28, 27, 7, 24, 29, 25, 23, 26
   \              1B07181D1917
   \              1A          
    295          
    296          /* =========================================================================
    297          Вспомогательная функция work_2s - обработка двухбуквенного сочетания.
    298          Вход:  с1 - порядковый номер первой буквы (0-31),
    299          c2 - порядковый номер второй буквы (0-31),
    300          check - надо ли проверять, встречалось ли сочетание раньше
    301          (1 - да, 0 - нет),
    302          buf - адрес массива с информацией о встреченных сочетаниях.
    303          Выход: 0 - указанное сочетание уже встречалось раньше,
    304          1 - сочетание не встречалось раньше и является допустимым,
    305          2 - сочетание не встречалось раньше и является недопустимым.
    306          ========================================================================= */
    307          

   \                                 In segment CODE, align 4, keep-with-next
    308          unsigned int work_2s (unsigned int c1, unsigned int c2, unsigned int check, unsigned char buf[128])
    309          {
    310            unsigned int i=(c1<<2)+(c2>>3); /* Номер байта в массиве. */
   \                     work_2s:
   \   00000000   A1C1A0E1           LSR      R12,R1,#+3
   \   00000004   00018CE0           ADD      R0,R12,R0, LSL #+2
    311            unsigned int mask=0x80>>(c2&7); /* Маска, соответствующая номеру бита в байте. */
   \   00000008   80C0A0E3           MOV      R12,#+128
   \   0000000C   071001E2           AND      R1,R1,#0x7
   \   00000010   3C11A0E1           LSR      R1,R12,R1
    312          
    313            /* Если check=1, проверяем: если соответствующий бит массива buf равен 0,
    314            значит, указанное сочетание уже встречалось раньше. Тогда выходим из
    315            функции, возвращая 0. Если же сочетание не встречалось, то помечаем, что
    316            оно встретилось (обнуляем соответствующий бит массива buf). */
    317          
    318            if (check==1)
   \   00000014   010052E3           CMP      R2,#+1
   \   00000018   0600001A           BNE      ??work_2s_0
    319            {
    320              if ((buf[i]&mask)==0) return (0);
   \   0000001C   032080E0           ADD      R2,R0,R3
   \   00000020   0030D2E5           LDRB     R3,[R2, #+0]
   \   00000024   030011E1           TST      R1,R3
   \   00000028   0000A003           MOVEQ    R0,#+0
   \   0000002C   1EFF2F01           BXEQ     LR
    321              buf[i]&=~mask;
   \   00000030   0130C3E1           BIC      R3,R3,R1
   \   00000034   0030C2E5           STRB     R3,[R2, #+0]
    322            }
    323          
    324            /* Проверяем, допустимо сочетание или нет. */
    325          
    326            if ((table_2s[i]&mask)!=0) return (1); /* Допустимо. */
   \                     ??work_2s_0:
   \   00000038   ........           LDR      R2,??DataTable6  ;; table_2s
   \   0000003C   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000040   000011E1           TST      R1,R0
   \   00000044   0100A013           MOVNE    R0,#+1
   \   00000048   1EFF2F11           BXNE     LR
    327            return (2);                            /* Недопустимо. */
   \   0000004C   0200A0E3           MOV      R0,#+2
   \   00000050   1EFF2FE1           BX       LR               ;; return
    328          }
    329          
    330          /* =========================================================================
    331          Вспомогательная функция def_code - определение кодировки текста. Функции
    332          m_def_code и f_def_code - лишь надстройки над этой функцией.
    333          Вход:  get_char - указатель на функцию, которую надо вызывать для получения
    334          очередного символа текста. Функция должна возвращать либо
    335          код символа, либо, при достижении конца текста, -1.
    336          n - количество различных сочетаний русских букв (1-255), которого
    337          достаточно для определения кодировки.
    338          Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI.
    339          ========================================================================= */
    340          

   \                                 In segment CODE, align 4, keep-with-next
    341          unsigned int def_code (void)
    342          {
   \                     def_code:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   41DF4DE2           SUB      SP,SP,#+260
    343            /* В массиве buf_1 хранится информация о том, какие сочетания руских букв
    344            уже встречались в варианте ALT, а в массиве buf_2 - в варианте WIN. */
    345          
    346            unsigned char buf_1 [128];
    347            unsigned char buf_2 [128];
    348          
    349          
    350            unsigned int s=0;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   00108DE5           STR      R1,[SP, #+0]
    351          
    352            unsigned int bad_1=0;
    353            unsigned int bad_2=0;
   \   00000010   0150A0E1           MOV      R5,R1
    354            unsigned int bad_3=0;
   \   00000014   0160A0E1           MOV      R6,R1
    355            unsigned int all_1=0;
   \   00000018   0170A0E1           MOV      R7,R1
    356            unsigned int all_3=0;  /* all_2=all_3 */
   \   0000001C   0180A0E1           MOV      R8,R1
    357          
    358            unsigned int c1;
    359            unsigned int c2=0; /* Символы текущего обрабатываемого сочетания. */
   \   00000020   0190A0E1           MOV      R9,R1
    360          
    361            /* Инициализация buf_1 и buf_2. */
    362          
    363            my_memset(buf_1,0xFF,sizeof(buf_1));
   \   00000024   8020A0E3           MOV      R2,#+128
   \   00000028   FF10A0E3           MOV      R1,#+255
   \   0000002C   04008DE2           ADD      R0,SP,#+4
   \   00000030   BB0000EF           SWI      +187
    364            my_memset(buf_2,0xFF,sizeof(buf_2));
   \   00000034   8020A0E3           MOV      R2,#+128
   \   00000038   FF10A0E3           MOV      R1,#+255
   \   0000003C   84008DE2           ADD      R0,SP,#+132
   \   00000040   BB0000EF           SWI      +187
   \   00000044   0040A0E3           MOV      R4,#+0
   \   00000048   020000EA           B        ??def_code_0
    365          
    366            /* Главный цикл - обработка сочетаний для каждого из трёх вариантов. Цикл
    367            выполняется, пока не кончится текст или в каком-либо из вариантов не
    368            встретится n сочетаний. */
    369          
    370            while ((s<16384)&&(all_1<255)&&(all_3<255))
   \                     ??def_code_1:
   \   0000004C   FF0057E3           CMP      R7,#+255
   \   00000050   FF005833           CMPCC    R8,#+255
   \   00000054   5400002A           BCS      ??def_code_2
    371            {
    372              c1=c2;
    373              if ((c2=dstk[s])==0) break;
   \                     ??def_code_0:
   \   00000058   ........           LDR      R2,??DataTable5  ;; dstk
   \   0000005C   00109DE5           LDR      R1,[SP, #+0]
   \   00000060   002092E5           LDR      R2,[R2, #+0]
   \   00000064   0900A0E1           MOV      R0,R9
   \   00000068   0290D1E7           LDRB     R9,[R1, +R2]
   \   0000006C   000059E3           CMP      R9,#+0
   \   00000070   4D00000A           BEQ      ??def_code_2
    374              s++;
   \   00000074   012081E2           ADD      R2,R1,#+1
    375              /* Вариант ALT. Вначале проверяем, являются ли символы текущего сочетания
    376              кодами русских букв в кодировке ALT. */
    377          
    378              if ((((c1>=0x80)&&(c1<0xB0))||((c1>=0xE0)&&(c1<0xF0)))&&
    379          	(((c2>=0x80)&&(c2<0xB0))||((c2>=0xE0)&&(c2<0xF0))))
   \   00000078   ........           LDR      R1,??DataTable6  ;; table_2s
   \   0000007C   00208DE5           STR      R2,[SP, #+0]
   \   00000080   8020A0E3           MOV      R2,#+128
   \   00000084   800050E3           CMP      R0,#+128
   \   00000088   0100003A           BCC      ??def_code_3
   \   0000008C   B00050E3           CMP      R0,#+176
   \   00000090   0300003A           BCC      ??def_code_4
   \                     ??def_code_3:
   \   00000094   E00050E3           CMP      R0,#+224
   \   00000098   2000003A           BCC      ??def_code_5
   \   0000009C   F00050E3           CMP      R0,#+240
   \   000000A0   1E00002A           BCS      ??def_code_5
   \                     ??def_code_4:
   \   000000A4   800059E3           CMP      R9,#+128
   \   000000A8   0100003A           BCC      ??def_code_6
   \   000000AC   B00059E3           CMP      R9,#+176
   \   000000B0   0300003A           BCC      ??def_code_7
   \                     ??def_code_6:
   \   000000B4   E00059E3           CMP      R9,#+224
   \   000000B8   1800003A           BCC      ??def_code_5
   \   000000BC   F00059E3           CMP      R9,#+240
   \   000000C0   1600002A           BCS      ??def_code_5
    380              {
    381                switch (work_2s(alt2num(c1),alt2num(c2),1,buf_1)) /* Обработали. */
   \                     ??def_code_7:
   \   000000C4   0930A0E1           MOV      R3,R9
   \   000000C8   E00053E3           CMP      R3,#+224
   \   000000CC   303043A2           SUBGE    R3,R3,#+48
   \   000000D0   00A0A0E1           MOV      R10,R0
   \   000000D4   E0005AE3           CMP      R10,#+224
   \   000000D8   30A04AA2           SUBGE    R10,R10,#+48
   \   000000DC   1F3003E2           AND      R3,R3,#0x1F
   \   000000E0   1FA00AE2           AND      R10,R10,#0x1F
   \   000000E4   A3C1A0E1           LSR      R12,R3,#+3
   \   000000E8   0AC18CE0           ADD      R12,R12,R10, LSL #+2
   \   000000EC   04A08DE2           ADD      R10,SP,#+4
   \   000000F0   0AE08CE0           ADD      LR,R12,R10
   \   000000F4   00A0DEE5           LDRB     R10,[LR, #+0]
   \   000000F8   073003E2           AND      R3,R3,#0x7
   \   000000FC   3233A0E1           LSR      R3,R2,R3
   \   00000100   0A0013E1           TST      R3,R10
   \   00000104   0500000A           BEQ      ??def_code_5
   \   00000108   03A0CAE1           BIC      R10,R10,R3
   \   0000010C   00A0CEE5           STRB     R10,[LR, #+0]
   \   00000110   01A0DCE7           LDRB     R10,[R12, +R1]
    382                {
    383                case 2: bad_1++;
    384                case 1: all_1++;
   \   00000114   017087E2           ADD      R7,R7,#+1
   \   00000118   0A0013E1           TST      R3,R10
   \   0000011C   01408402           ADDEQ    R4,R4,#+1
    385                }
    386              }
    387              /* Варианты WIN и KOI. Вначале проверяем, являются ли символы текущего
    388              сочетания кодами русских букв в этих кодировках (в обеих кодировках
    389              диапазоны кодов русских букв совпадают). */
    390          
    391              if ((c1&c2)>=0xC0) /* Эквивалентно условию (c1>=0xC0)&&(c2>=0xC0). */
   \                     ??def_code_5:
   \   00000120   003009E0           AND      R3,R9,R0
   \   00000124   C00053E3           CMP      R3,#+192
   \   00000128   1C00003A           BCC      ??def_code_8
    392              {
    393                switch (work_2s(c1&31,c2&31,1,buf_2)) /* Обработали. */
   \   0000012C   1FA009E2           AND      R10,R9,#0x1F
   \   00000130   1F3000E2           AND      R3,R0,#0x1F
   \   00000134   AAB1A0E1           LSR      R11,R10,#+3
   \   00000138   03318BE0           ADD      R3,R11,R3, LSL #+2
   \   0000013C   84B08DE2           ADD      R11,SP,#+132
   \   00000140   0BC083E0           ADD      R12,R3,R11
   \   00000144   00E0DCE5           LDRB     LR,[R12, #+0]
   \   00000148   07A00AE2           AND      R10,R10,#0x7
   \   0000014C   32AAA0E1           LSR      R10,R2,R10
   \   00000150   0AB0A0E1           MOV      R11,R10
   \   00000154   0E001BE1           TST      R11,LR
   \   00000158   1000000A           BEQ      ??def_code_8
   \   0000015C   0BB0CEE1           BIC      R11,LR,R11
   \   00000160   00B0CCE5           STRB     R11,[R12, #+0]
   \   00000164   0130D3E7           LDRB     R3,[R3, +R1]
    394                {
    395                case 0: continue; /* Если сочетание букв уже встречалось в варианте WIN,
    396                то оно уже встречалось и в варианте KOI, так что
    397                пропускаем обработку варианта KOI и переходим
    398                к следующей итерации главного цикла. */
    399                case 2: bad_2++;
    400                }
    401          
    402                /* Если сочетание букв ещё не встречалось в варианте WIN, то оно заведомо
    403                не встречалось и в варианте KOI, поэтому специально проверять это не
    404                надо - значит, функцию work_2s вызываем с параметром check, равным 0. */
    405          
    406                switch (work_2s(koi2num(c1),koi2num(c2),0,NULL)) /* Обработали. */
   \   00000168   1F0000E2           AND      R0,R0,#0x1F
    407                {
    408                case 2: bad_3++;
    409                case 1: all_3++;
   \   0000016C   018088E2           ADD      R8,R8,#+1
   \   00000170   03001AE1           TST      R10,R3
   \   00000174   ........           LDR      R10,??DataTable7  ;; ??t
   \   00000178   1F3009E2           AND      R3,R9,#0x1F
   \   0000017C   0A30D3E7           LDRB     R3,[R3, +R10]
   \   00000180   0A00D0E7           LDRB     R0,[R0, +R10]
   \   00000184   01508502           ADDEQ    R5,R5,#+1
   \   00000188   A3A1A0E1           LSR      R10,R3,#+3
   \   0000018C   00018AE0           ADD      R0,R10,R0, LSL #+2
   \   00000190   0100D0E7           LDRB     R0,[R0, +R1]
   \   00000194   071003E2           AND      R1,R3,#0x7
   \   00000198   320110E1           TST      R0,R2, LSR R1
   \   0000019C   01608602           ADDEQ    R6,R6,#+1
    410                }
    411              }
    412            }
   \                     ??def_code_8:
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   400C50E3           CMP      R0,#+16384
   \   000001A8   A7FFFF3A           BCC      ??def_code_1
    413          
    414            /* Данные собраны. Теперь, если в каком-либо из вариантов недопустимых
    415            сочетаний не больше 1/32 от общего их числа, то считаем, что их и не
    416            было. */
    417          
    418            if (bad_1<=(all_1>>5)) bad_1=0;
   \                     ??def_code_2:
   \   000001AC   A70254E1           CMP      R4,R7, LSR #+5
   \   000001B0   0040A093           MOVLS    R4,#+0
    419            if (bad_2<=(all_3>>5)) bad_2=0;
   \   000001B4   A802A0E1           LSR      R0,R8,#+5
   \   000001B8   050050E1           CMP      R0,R5
   \   000001BC   0050A023           MOVCS    R5,#+0
    420            if (bad_3<=(all_3>>5)) bad_3=0;
   \   000001C0   060050E1           CMP      R0,R6
   \   000001C4   0060A023           MOVCS    R6,#+0
    421          
    422            /* Получаем результат. */
    423          
    424            {
    425              unsigned int a=((255-bad_1)<<8)+all_1;
   \   000001C8   FF0064E2           RSB      R0,R4,#+255
   \   000001CC   000487E0           ADD      R0,R7,R0, LSL #+8
    426              unsigned int b=((255-bad_2)<<8)+all_3;
   \   000001D0   FF1065E2           RSB      R1,R5,#+255
   \   000001D4   011488E0           ADD      R1,R8,R1, LSL #+8
    427              unsigned int c=((255-bad_3)<<8)+all_3;
   \   000001D8   FF2066E2           RSB      R2,R6,#+255
   \   000001DC   022488E0           ADD      R2,R8,R2, LSL #+8
    428          
    429              if ((a>=b)&&(a>=c)) return (0);
   \   000001E0   010050E1           CMP      R0,R1
   \   000001E4   02005021           CMPCS    R0,R2
   \   000001E8   0000A023           MOVCS    R0,#+0
   \   000001EC   0200002A           BCS      ??def_code_9
    430              if (b>=c) return (1); else return (2);
   \   000001F0   020051E1           CMP      R1,R2
   \   000001F4   0100A023           MOVCS    R0,#+1
   \   000001F8   0200A033           MOVCC    R0,#+2
   \                     ??def_code_9:
   \   000001FC   41DF8DE2           ADD      SP,SP,#+260      ;; stack cleaning
   \   00000200   F08FBDE8           POP      {R4-R11,PC}      ;; return
    431            }
    432          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     win_dos_koi

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     dstk

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     table_2s

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     ??t

   Maximum stack usage in bytes:

     Function      CSTACK
     --------      ------
     ConvertFormat   316
     GetCharType_x     0
     alt2num           0
     def_code        296
     koi2num           0
     work_2s           0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     ctype           128
     GetCharType_x   140
     ConvertFormat  1032
     table_2s        128
     alt2num          16
     koi2num          16
     t                32
     work_2s          84
     def_code        516
     ??DataTable1      4
     ??DataTable5      4
     ??DataTable6      4
     ??DataTable7      4
      Others          48

 
 1 868 bytes in segment CODE
   288 bytes in segment DATA_C
 
 1 820 bytes of CODE  memory (+ 48 bytes shared)
   288 bytes of CONST memory

Errors: none
Warnings: none
